'use strict';

/*树结构数据的相关操作工具方法*/
var React = require('react');
var _ = require('lodash');
function getChildrenlength(children) {
    var len = 1;
    if (Array.isArray(children)) {
        len = children.length;
    }
    return len;
}
function getSiblingPosition(index, len, siblingPosition) {
    if (len === 1) {
        siblingPosition.first = true;
        siblingPosition.last = true;
    } else {
        siblingPosition.first = index === 0;
        siblingPosition.last = index === len - 1;
    }
    return siblingPosition;
}
var TreeUtils = {
    /**
     * 遍历树结构子集对象
     * @param childs  {array} 需要遍历的树结构
     * @param callback {function} 遍历时的回调函数，传递参数：item(当前结点)、index(当前索引)、pos(当前层级和索引)、key、siblingPos(兄弟节点间的索引)、parent
     * @param parent {object} 当前父级节点
     */
    loopAll: function loopAll(childs, callback, parent) {
        var loop = function loop(children, level, _parent) {
            var len = getChildrenlength(children);
            _.forEach(children, function (item, index) {
                var pos = level + '-' + index;
                if (item) {
                    if (_.isArray(item.children)) {
                        loop(item.children, pos, { node: item, pos: pos });
                    }
                    callback(item, index, pos, item.key || pos, getSiblingPosition(index, len, {}), _parent);
                }
            });
        };
        loop(childs, 0, parent);
    }
    /**
     * 查找树节点下指定节点属性值匹配的节点
     * @param nodes {array} 子节点集合
     * @param propName {string} 属性名
     * @param propValue {*} 属性值
     * @param loop{boolean} 默认：true，是否递归遍历子集合
     * @param only{boolean} 默认：true，是否匹配到第一个就终止
     * @param childPropName{boolean} 默认：children，子节点集合的属性名
     */
    , findWithPropName: function findWithPropName(nodes, propName, propValue, loop, only, childPropName) {
        var _results = [];
        var _nodes = _.isArray(nodes) ? nodes : [];
        var _childPropName = childPropName ? childPropName : 'children';
        for (var i = 0; i < _nodes.length; i++) {
            var node = _nodes[i];
            if (!_.isObject(node)) continue;
            if (node[propName] && node[propName] == propValue) {
                _results.push(node);
                if (only == undefined || only == true) break;
            }
            if (loop != false && node[_childPropName] && node[_childPropName].length > 0) {
                var currResults = this.findWithPropName(node[_childPropName], propName, propValue, loop, only, _childPropName);
                if (currResults != null) {
                    _results = _results.concat(currResults);
                }
            }
        }
        return _results;
    }
    /**
     * 移除树节点下指定节点属性值匹配的节点
     * @param tree {object} 子节点集合
     * @param propName {string} 属性名
     * @param propValue {*} 属性值
     * @param loop{boolean} 默认：true，是否递归遍历子集合
     * @param childName 子集合的属性名
     */
    , removeWithPropName: function removeWithPropName(tree, propName, propValue, loop) {
        var childName = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "children";

        var doLoop = function doLoop(data, propName, propVal, callback) {
            data.forEach(function (item, index, arr) {
                if (item[propName] === propVal) {
                    return callback(item, index, arr);
                }
                if (loop != false && _.isArray(item[childName])) {
                    return doLoop(item[childName], propName, propVal, callback);
                }
            });
        };
        if (tree && propName && propValue) {
            doLoop(_.isArray(tree) ? tree : [tree], propName, propValue, function (item, index, arr) {
                arr.splice(index, 1);
            });
        }
        return tree;
    }
    /**
     * 通过ID查找树节点
     * @param nodes {array} 子节点集合
     * @param idValue {*} ID属性值
     */
    , findById: function findById(nodes, idValue) {
        var results = this.findWithPropName(nodes, 'id', idValue, true, true);
        return results.length > 0 ? results[0] : null;
    }
    /**
     * 删除树下对应ID的节点
     * @param tree {object} 树结构对象
     * @param nodeId {*} 树节点id
     */
    , removeById: function removeById(tree, nodeId) {
        var tree = this.removeWithPropName(tree, 'id', nodeId, true);
        return tree;
    }

};
module.exports = TreeUtils;