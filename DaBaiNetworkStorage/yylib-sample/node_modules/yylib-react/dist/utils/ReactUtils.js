'use strict';

/**
 * Created by wuhao on 16/9/24.
 */
var React = require('react');
var _ = require('lodash');

//获取元素的计算样式
function getTheStyle(ele, rule) {
    if (ele.currentStyle) {
        return ele.currentStyle[rule];
    }
    return window.getComputedStyle(ele).getPropertyValue(rule);
}
//获取原素的外部高度包括 padding，border，margin，及内容高度
function outerHeight(ele) {
    var height = ele.offsetHeight;
    var style = ele.currentStyle || getComputedStyle(ele);

    height += parseInt(style.marginTop) + parseInt(style.marginBottom);
    return height;
}
//获取元素的标签名称
function getNodeName(ele, name) {
    return ele.nodeName.toUpperCase();
}
function getChildrenlength(children) {
    var len = 1;
    if (Array.isArray(children)) {
        len = children.length;
    }
    return len;
}
function getSiblingPosition(index, len, siblingPosition) {
    if (len === 1) {
        siblingPosition.first = true;
        siblingPosition.last = true;
    } else {
        siblingPosition.first = index === 0;
        siblingPosition.last = index === len - 1;
    }
    return siblingPosition;
}
var ReactUtils = {
    /**
     * 遍历树React对象结构的子集对象
     * @param childs  {array} 需要遍历的树结构
     * @param callback {function} 遍历时的回调函数，传递参数：item(当前结点)、index(当前索引)、pos(当前层级和索引)、key、siblingPos(兄弟节点间的索引)、parent
     * @param parent {object} 当前父级节点
     */
    loopAllChildren: function loopAllChildren(childs, callback, parent) {
        var loop = function loop(children, level, _parent) {
            var len = getChildrenlength(children);
            React.Children.forEach(children, function (item, index) {
                var pos = level + '-' + index;
                if (item.props.children) {
                    loop(item.props.children, pos, { node: item, pos: pos });
                }
                callback(item, index, pos, item.key || pos, getSiblingPosition(index, len, {}), _parent);
            });
        };
        loop(childs, 0, parent);
    },
    /**
     * 递归获取React元素子集的文本集合
     * @param elem
     * @param results
     * @returns {*}
     */
    getChildrenText: function getChildrenText(elem, results) {
        var _results = results ? results : [];
        if (!React.isValidElement(elem) && (_.isString(elem) || !_.isNaN(elem))) {
            _results.push(elem);
        } else {
            if (React.isValidElement(elem)) {
                //react对象则遍历children
                var self = this;
                if (_.isArray(elem.props.children)) {
                    _.forEach(elem.props.children, function (item) {
                        self.getChildrenText(item, _results);
                    });
                } else {
                    self.getChildrenText(elem.props.children, _results);
                }
            }
        }
        return _results;
    }
    //判断两个数组里面的值是否一致
    , isArrayEqual: function isArrayEqual(arr1, arr2) {
        var result = _.isEqual(arr1, arr2);
        //特殊处理 arr1=['2','3'] arr2=['3','2'] 调用 _.isEqual  ==> false 的情况
        if (result == false && _.isArray(arr1) && _.isArray(arr2) && (arr1.length > 0 || arr2.length > 0)) {
            //先排序再转化成字符串比较
            result = arr1.sort().toString() == arr2.sort().toString();
        }
        return result;
    }
    /**
    * @desc 填充全屏
    * @param element - 需要填充全屏的DOM元素
    * @param func - 自定义填充
    * 	传递参数：elem - 当前元素		pageW - 页面宽度	pageH - 页面高度
    */
    , fillScreen: function fillScreen(elem, func) {
        var pageW = window.innerWidth,
            pageH = window.innerHeight;
        if (!_.isNumber(pageW) || !_.isNumber(pageH)) {
            if (document.compatMode == "CSS1Compat") {
                //是否处于标准模式
                pageW = document.documentElement.clientWidth;
                pageH = document.documentElement.clientHeight;
            } else {
                pageW = document.body.clientWidth;
                pageH = document.body.clientHeight;
            }
        }
        if (_.isFunction(func)) {
            func.call(this, elem, pageW, pageH);
        } else {
            elem.style.width = pageW + 'px';
            elem.style.height = pageH + 'px';
        }
    }
    /**
    * @desc 填充空白
    * @param elem 需要填充的元素
    * @param target 填充参考的父容器元素
    * @param func 自处理填充
    * 传递参数：
    * 	element - 当前元素
    * 	parent	 - 目标元素
    * 	maxWidth - 预计最大宽度
    * 	maxHeight - 预计最大高度
    */
    , fillSpace: function fillSpace(element, target, func) {
        var _this = this;
        var parent = null;
        var isParent = false;
        if (target) {
            isParent = false;
        } else {
            parent = element.parentNode;
            isParent = true;
        }
        var overflow, maxHeight, maxWidth;
        //如果为form元素则取其父级
        if (getNodeName(parent) === 'FORM') {
            parent = parent.parentNode;
        }
        //如果父级是body则认为是全屏
        if (getNodeName(parent) === 'BODY') {
            parent.style.overflow = "hidden";
        } else {
            parent.style.overflow = "visible";
        }

        maxHeight = parent.clientHeight;
        maxWidth = parent.clientWidth;
        //排除当前元素可见的兄弟节点高度
        var siblings = Array.prototype.slice.call(element.parentNode.children);
        _.forEach(siblings, function (sibling) {
            if (getTheStyle(sibling, 'display') !== 'none') {
                var position = getTheStyle(sibling, 'position');
                if (position === "absolute" || position === "fixed") {
                    return;
                }
                maxHeight -= outerHeight(sibling);
            }
        });
        //如果当前元素不属于目标元素的一级子集
        if (!isParent) {
            //排除目标元素中除当前元素父元素以外的其它元素高度
            var children = Array.prototype.slice.call(parent.children);
            _.forEach(children, function (child) {
                maxHeight -= outerHeight(child);
            });
        }

        //注意：排除padding的尺寸
        var elemW = parseInt(getTheStyle(element, 'width'));
        var elemH = parseInt(getTheStyle(element, 'height'));
        var noPaddingMaxW = Math.max(0, maxWidth - element.clientWidth + elemW);
        var noPaddingMaxH = Math.max(0, maxHeight - element.clientHeight + elemH);
        if (_.isFunction(func)) {
            func.call(this, element, parent, noPaddingMaxW, noPaddingMaxH);
        } else {
            if (getNodeName(parent) === "BODY") {
                //如果父级为body元素
                if (parent.childNodes.length <= 1) {
                    this.fillScreen(element); //则填充全屏
                } else {
                    //排除其它元素高度
                    var _otherH = 0;
                    var _children = Array.prototype.slice.call(parent.children);
                    _.forEach(_children, function (child) {
                        if (getTheStyle(child, 'display') !== 'none' && child != element) {
                            var position = getTheStyle(child, 'position');
                            if (position === "absolute") {
                                //此元素为悬浮，不算在全局填充之内
                            } else {
                                _otherH += outerHeight(elem);
                            }
                        }
                    });

                    this.fillScreen(element, function (elem, pageW, pageH) {
                        elem.style.width = pageW + 'px';
                        elem.style.height = pageH - _otherH + 'px';
                    });
                }
                parent.style.overflow = "hidden";
            } else {
                element.style.width = noPaddingMaxW + 'px';
                element.style.height = noPaddingMaxH + 'px';
            }
        }
    }
};

module.exports = ReactUtils;