'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var React = require('react');
var _ = require('lodash');

var _require = require('yylib-ui'),
    YYClass = _require.YYClass,
    YYEditTable = _require.YYEditTable,
    YYDatePicker = _require.YYDatePicker,
    YYCascader = _require.YYCascader,
    YYTimePicker = _require.YYTimePicker,
    YYSwitch = _require.YYSwitch,
    YYIcon = _require.YYIcon,
    YYSelect = _require.YYSelect,
    YYInput = _require.YYInput,
    YYInputNumber = _require.YYInputNumber,
    YYInputCurrency = _require.YYInputCurrency,
    YYReferInput = _require.YYReferInput,
    YYDropdown = _require.YYDropdown,
    YYMenu = _require.YYMenu,
    YYMenuItem = _require.YYMenuItem,
    YYTooltip = _require.YYTooltip;

var YYEnumSelect = require('../enum/YYEnumSelect');
var formatUtils = require('yylib-utils/formatUtils');
var FormItemType = require('./FormItemType');
var AttachUploadWidget = require('./attach/AttachUploadWidget');
var BaseHost = require('../BaseHost');
// 更改单元格数据event-事件对象或者值
function onCellChange(cellOpts, event, value2, fullValue, selectedNode) {
    // rowData-行数据、rowIndex-行索引、dataIndex-列索引名、props-列定义属性
    var rowData = cellOpts.rowData,
        rowIndex = cellOpts.rowIndex,
        dataIndex = cellOpts.dataIndex,
        props = cellOpts.props;
    //获取修改后的单元格数据，注意：此处依据输入类型不同，取值行为需要进行对应调整（如：参照、勾选、输入框等），通过dataIndex可判断当前是哪列，即可明确取值行为。

    var newVal = event && event.target ? event.target.value : event;
    //日期控件返回的格式为Date对象，所以需要取后面的参数值
    if (newVal instanceof Date) newVal = value2;
    var self = this;
    //console.log('inner onCellChange--->',index,dataIndex,newVal);
    //修改指定单元格的值，此方法由YYEditTable提供
    var rowKeyField = self.props.rowKey;
    this.saveCellData(rowData[rowKeyField], dataIndex, newVal, function (allRows) {
        //回调外部绑定的EditTableWidget.onCellChange
        if (_.isFunction(self.props.onCellChange)) {
            //numVal-精确数值控件返回的数值、datestr-日期控件返回的字符串值、fullValue-参照全字段、selectedNode-树表参照当前选中的节点信息
            self.props.onCellChange({ rowData: rowData, rowIndex: rowIndex, dataIndex: dataIndex, event: event, newVal: newVal, numVal: value2, datestr: value2, fullValue: fullValue, selectedNode: selectedNode });
        }
    });
}

function renderInput(options) {
    var props = options.props,
        value = options.value,
        rowData = options.rowData,
        index = options.index,
        editable = options.editable;

    var inputProps = {};
    if (props) {
        if (props.maxLength) {
            inputProps.maxLength = props.maxLength;
        }
        if (props.defaultValue) {
            inputProps.defaultValue = props.defaultValue;
        }
        if (props.addonAfter) {
            inputProps.addonAfter = props.addonAfter;
        }
        if (props.onBlur) {
            inputProps.onBlur = props.onBlur;
        }
        if (props.placeholder) {
            inputProps.placeholder = props.placeholder;
        }
    }
    if (editable !== false && rowData.isEdit && props.editable !== false) {
        //编辑态显示
        return React.createElement(YYInput, _extends({}, inputProps, { value: value, onChange: onCellChange.bind(this, { rowData: rowData, rowIndex: index, dataIndex: props.dataIndex, props: props }) }));
    } else {
        //非编辑态显示
        return value;
    }
}
function renderSelect(options) {
    var props = options.props,
        value = options.value,
        rowData = options.rowData,
        index = options.index,
        editable = options.editable;

    var selectProps = {};
    if (props) {
        if (props.children) {
            selectProps.items = _.map(props.children, function (child) {
                if (React.isValidElement(child)) {
                    // child 为React元素时
                    return {
                        value: child.props.value,
                        text: child.props.text
                    };
                } else {
                    return { // child为对象时
                        value: child.value,
                        text: child.text
                    };
                }
            });
        }
        if (props.disabled) {
            selectProps.disabled = props.disabled;
        }
        if (props.allowClear) {
            selectProps.allowClear = props.allowClear;
        }
        if (props.valueType) {
            selectProps.valueType = props.valueType;
        }
        if (props.valueKey) {
            selectProps.valueKey = props.valueKey;
        }
        if (props.textKey) {
            selectProps.textKey = props.textKey;
        }
        if (props.dataurl) {
            selectProps.dataurl = props.dataurl;
        }
        if (props.dataparams) {
            selectProps.dataparams = props.dataparams;
        }
        if (props.multiple) {
            selectProps.multiple = props.multiple;
        }
        if (props.onShowFilter) {
            selectProps.onShowFilter = props.onShowFilter;
        }
    }

    if (rowData.isEdit && props.editable !== false && editable !== false) {
        //编辑态显示
        return React.createElement(YYSelect, _extends({}, selectProps, { defaultValue: value, onChange: onCellChange.bind(this, { rowData: rowData, rowIndex: index, dataIndex: props.dataIndex, props: props }) }));
    } else {
        //非编辑态显示
        if (props.multiple == true) {
            //多选模式
            if (_.isArray(value)) {
                var names = [];
                _.forEach(value, function (optionValue) {
                    var currOption = _.find(props.children, { value: optionValue });
                    if (currOption) {
                        names.push(currOption.text);
                    }
                });
                return names.join(',');
            } else {
                return '';
            }
        } else {
            //单选模式
            var currOption = _.find(props.children, { value: value });
            return currOption ? currOption.text : '';
        }
    }
}
function renderInputRefer(options) {
    var props = options.props,
        value = options.value,
        rowData = options.rowData,
        index = options.index,
        editable = options.editable;

    var referProps = {};
    if (props) {
        if (props.refinfokey) {
            referProps.refinfokey = props.refinfokey;
        }
        if (props.multiselect) {
            referProps.multiselect = props.multiselect;
        }
        if (props.often) {
            referProps.often = props.often;
        }
        if (props.searchPlaceholder) {
            referProps.searchPlaceholder = props.searchPlaceholder;
        }
        if (props.condition) {
            referProps.condition = props.condition;
        }
        if (props.checkControl !== undefined && props.checkControl !== null) {
            referProps.checkControl = props.checkControl;
        }
        if (props.onNodeSelect) {
            referProps.onNodeSelect = props.onNodeSelect;
        }
        if (props.onShow) {
            referProps.onShow = props.onShow;
        }
    }
    if (rowData.isEdit && props.editable !== false && editable !== false) {
        //编辑态显示
        //注意：依据环境标识，自动配置serverUrl的地址
        referProps.serverUrl = BaseHost;
        return React.createElement(YYReferInput, _extends({}, referProps, {
            defaultValue: value,
            onChange: onCellChange.bind(this, { rowData: rowData, rowIndex: index, dataIndex: props.dataIndex, props: props }) }));
    } else {
        //非编辑态显示
        if (props.multiselect == true) {
            //多选模式
            if (_.isArray(value)) {
                var names = _.map(value, function (item) {
                    return _.isObject(item) ? item.name : item;
                });
                return names.join(',');
            } else {
                return '';
            }
        } else {
            //单选模式
            return _.isObject(value) ? value.name : value;
        }
    }
}
function renderDate(options) {
    var props = options.props,
        value = options.value,
        rowData = options.rowData,
        index = options.index,
        editable = options.editable;

    var dateProps = {};
    if (props && props.format) {
        dateProps.format = props.format;
    }
    if (props.disabledDate) {
        dateProps.disabledDate = props.disabledDate;
        dateProps.disabledDate = dateProps.disabledDate.bind(this, { rowData: rowData, index: index, dataIndex: props.dataIndex });
    }
    if (props.toggleOpen) {
        dateProps.toggleOpen = props.toggleOpen;
    }
    if (props.placeholder) {
        dateProps.placeholder = props.placeholder;
    }
    if (rowData.isEdit && props.editable !== false && editable !== false) {
        //编辑态显示
        return React.createElement(YYDatePicker, _extends({}, dateProps, { value: value, onChange: onCellChange.bind(this, { rowData: rowData, rowIndex: index, dataIndex: props.dataIndex, props: props }) }));
    } else {
        //非编辑态显示
        return formatUtils.formatDate(value, props.format);
    }
}
function renderNumber(options) {
    var props = options.props,
        value = options.value,
        rowData = options.rowData,
        index = options.index,
        editable = options.editable;

    var numProps = {};
    if (props) {
        if (props.min != undefined && props.min != null) {
            numProps.min = props.min;
        }
        if (props.max != undefined && props.max != null) {
            numProps.max = props.max;
        }
        if (props.onBlur) {
            numProps.onBlur = props.onBlur;
        }
        if (props.placeholder) {
            numProps.placeholder = props.placeholder;
        }
        if (props.defaultValue) {
            numProps.defaultValue = props.defaultValue;
        }
    }
    if (props && props.type === 'currency') {
        numProps.type = props.type;
        if (props.addonAfter) {
            numProps.addonAfter = props.addonAfter;
        }
        if (props.commaVisible === false) {
            numProps.commaVisible = props.commaVisible;
        }
        if (props.decimal || props.decimal === 0) {
            numProps.decimal = props.decimal;
        }
        if (props.symbol || props.symbol === '') {
            numProps.symbol = props.symbol;
        }
        if (props.minus) {
            numProps.minus = props.minus;
        }
        if (props.direction) {
            numProps.direction = props.direction;
        }
    }
    if (rowData.isEdit && props.editable !== false && editable !== false) {
        //编辑态显示
        if (props && props.type == 'number') {
            //整数框编辑时需要清除千分位
            value = YYInputCurrency.clearComma(value);
        }
        return React.createElement(YYInputNumber, _extends({}, numProps, { value: value, onChange: onCellChange.bind(this, { rowData: rowData, rowIndex: index, dataIndex: props.dataIndex, props: props }) }));
    } else {
        //非编辑态显示
        if (props && props.type == 'currency') {
            //格式化显示精确数值
            var commaVisible = numProps.commaVisible,
                decimal = numProps.decimal,
                symbol = numProps.symbol;

            return YYInputCurrency.formatCurrency(value, {
                comma: commaVisible != undefined ? commaVisible : true,
                decimal: decimal,
                symbol: symbol
            });
        } else if (props && props.type == 'number') {
            //格式化显示整数值
            var commaVisible = numProps.commaVisible,
                symbol = numProps.symbol;

            return YYInputCurrency.formatCurrency(value, {
                comma: commaVisible != undefined ? commaVisible : true,
                decimal: 0,
                symbol: symbol
            });
        } else {
            return value;
        }
    }
}

function renderSwitch(options) {
    var props = options.props,
        value = options.value,
        rowData = options.rowData,
        index = options.index,
        editable = options.editable;

    var switchProps = {};
    if (props && props.defaultChecked) {
        switchProps.defaultChecked = props.defaultChecked;
    }
    if (props && props.checkedChildren) {
        switchProps.checkedChildren = props.checkedChildren;
    }
    if (props && props.unCheckedChildren) {
        switchProps.unCheckedChildren = props.unCheckedChildren;
    }
    if (rowData.isEdit && props.editable !== false && editable !== false) {
        //编辑态显示
        return React.createElement(YYSwitch, _extends({}, switchProps, { checked: value, onChange: onCellChange.bind(this, { rowData: rowData, rowIndex: index, dataIndex: props.dataIndex, props: props }) }));
    } else {
        //非编辑态显示
        var showView = value === undefined ? props.defaultChecked : value;
        if (showView) {
            return props && props.checkedChildren ? props.checkedChildren : '是';
        } else {
            return props && props.unCheckedChildren ? props.unCheckedChildren : '否';
        }
    }
}

function renderEnumSelect(options) {
    var props = options.props,
        value = options.value,
        rowData = options.rowData,
        index = options.index,
        editable = options.editable;

    var enumSelectProps = {};
    if (props.disabled) {
        enumSelectProps.disabled = props.disabled;
    }
    if (props.code) {
        enumSelectProps.code = props.code;
    }
    if (props.allowClear) {
        enumSelectProps.allowClear = props.allowClear;
    }
    if (props.enableOrg) {
        enumSelectProps.enableOrg = props.enableOrg;
    }
    if (props.serverUrl) {
        enumSelectProps.serverUrl = props.serverUrl;
    }
    if (props.valueType) {
        enumSelectProps.valueType = props.valueType;
    }
    if (props.valueKey) {
        enumSelectProps.valueKey = props.valueKey;
    }
    if (props.textKey) {
        enumSelectProps.textKey = props.textKey;
    }
    if (props.multiple) {
        enumSelectProps.multiple = props.multiple;
    }
    if (props.onShowFilter) {
        enumSelectProps.onShowFilter = props.onShowFilter;
    }
    if (props.propKey) {
        enumSelectProps.propKey = props.propKey;
    }
    if (props.defaultActiveFirstOption !== undefined) {
        enumSelectProps.defaultActiveFirstOption = props.defaultActiveFirstOption;
    }
    if (props.dataparams) {
        enumSelectProps.dataparams = props.dataparams;
    }
    if (rowData.isEdit && props.editable !== false && editable !== false) {
        return React.createElement(YYEnumSelect, _extends({}, enumSelectProps, { defaultValue: value, onChange: onCellChange.bind(this, { rowData: rowData, rowIndex: index, dataIndex: props.dataIndex, props: props }) }));
    } else {
        if (props.multiple == true) {
            //多选模式
            if (_.isArray(value)) {
                var names = _.map(value, function (item) {
                    return _.isObject(item) ? item.name : item;
                });
                return names.join(',');
            } else {
                return '';
            }
        } else {
            //单选模式
            return _.isObject(value) ? value.name : value;
        }
    }
}

function renderCascader(options) {
    var props = options.props,
        value = options.value,
        rowData = options.rowData,
        index = options.index,
        editable = options.editable;

    var cascaderProps = {};
    if (props.size) {
        cascaderProps.size = props.size;
    }
    if (props.options) {
        cascaderProps.options = props.options;
    }
    if (props.dataurl) {
        cascaderProps.dataurl = props.dataurl;
    }
    if (props.dataparams) {
        cascaderProps.dataparams = props.dataparams;
    }
    //编辑表格中固定取值类型为object
    cascaderProps.onChangeValueType = 'object';
    if (rowData.isEdit && props.editable !== false && editable !== false) {
        if (_.isArray(value)) {
            value = _.map(value, function (item) {
                if (_.isPlainObject(item)) {
                    return item.value;
                } else {
                    return item;
                }
            });
        }
        return React.createElement(YYCascader, _extends({}, cascaderProps, { defaultValue: value, onChange: onCellChange.bind(this, { rowData: rowData, rowIndex: index, dataIndex: props.dataIndex, props: props }) }));
    } else {
        if (_.isArray(value)) {
            var names = _.map(value, function (item) {
                return _.isObject(item) ? item.label : item;
            });
            return names.join('/');
        }
        return value;
    }
}

function renderAttachUpload(options) {
    var props = options.props,
        value = options.value,
        rowData = options.rowData,
        index = options.index,
        editable = options.editable;

    var uploadProps = {};
    if (props.action) {
        uploadProps.action = props.action;
    }
    if (props.title) {
        uploadProps.title = props.title;
    }
    if (props.enableUser) {
        uploadProps.enableUser = props.enableUser;
    }
    if (props.multiple) {
        uploadProps.multiple = props.multiple;
    }
    if (props.billType) {
        uploadProps.billType = props.billType;
    }
    if (props.sourceId) {
        uploadProps.sourceId = props.sourceId;
    }
    if (props.beforeUpload) {
        uploadProps.beforeUpload = props.beforeUpload;
    }
    if (props.beforeDel) {
        uploadProps.beforeDel = props.beforeDel;
    }
    if (props.sourceType) {
        uploadProps.sourceType = props.sourceType;
    }
    if (props.defaultValue) {
        uploadProps.defaultValue = props.defaultValue;
    }
    if (props.disabled !== undefined) {
        uploadProps.disabled = props.disabled;
    }
    if (rowData.isEdit && props.editable !== false && editable !== false) {
        return React.createElement(AttachUploadWidget, _extends({}, uploadProps, { onChange: onCellChange.bind(this, { rowData: rowData, rowIndex: index, dataIndex: props.dataIndex, props: props }) }));
    } else {
        return React.createElement(AttachUploadWidget, _extends({ disabled: true }, uploadProps));
    }
}

function renderTimePicker(options) {
    var props = options.props,
        value = options.value,
        rowData = options.rowData,
        index = options.index,
        editable = options.editable;

    var timePickerProps = {};
    if (props.placeholder) {
        timePickerProps.placeholder = props.placeholder;
    }
    if (props.format) {
        timePickerProps.format = props.format;
    }
    if (props.disabled != undefined && props.disabled != null) {
        timePickerProps.disabled = props.disabled;
    }
    if (props.disabledHours != undefined && props.disabledHours != null) {
        timePickerProps.disabledHours = props.disabledHours;
    }
    if (props.disabledMinutes != undefined && props.disabledMinutes != null) {
        timePickerProps.disabledMinutes = props.disabledMinutes;
    }
    if (props.disabledSeconds != undefined && props.disabledSeconds != null) {
        timePickerProps.disabledSeconds = props.disabledSeconds;
    }
    if (props.hideDisabledOptions != undefined && props.hideDisabledOptions != null) {
        timePickerProps.hideDisabledOptions = props.hideDisabledOptions;
    }
    if (props.getPopupContainer) {
        timePickerProps.getPopupContainer = props.getPopupContainer;
    }
    if (props.locale) {
        timePickerProps.locale = props.locale;
    }

    if (rowData.isEdit && props.editable !== false && editable !== false) {
        return React.createElement(YYTimePicker, _extends({}, timePickerProps, { onChange: onCellChange.bind(this, { rowData: rowData, rowIndex: index, dataIndex: props.dataIndex, props: props }) }));
    } else {
        return value;
    }
}

function doCellRender(props, value, rowData, index, rowKey) {
    //回调是否编辑的事件
    var editable = _.isFunction(props.isEditable) ? props.isEditable({ value: value, rowData: rowData, index: index, dataIndex: props.dataIndex }) : true;
    var options = { props: props, value: value, isEdit: rowData.isEdit, rowData: rowData, index: index, editable: editable };
    var view = null;
    var errorMsg = null;
    var cellFillView = null;
    var cellEditTip = null;
    //回调renderBefore事件
    if (_.isFunction(props.renderBefore)) {
        var returnOptions = props.renderBefore(options);
        if (_.isObject(returnOptions)) {
            options = _.assign(options, returnOptions);
        }
    }
    switch (props.uisubtype) {
        case FormItemType.input:
            view = renderInput.call(this, options);
            break;
        case FormItemType.select:
            view = renderSelect.call(this, options); //选项
            break;
        case FormItemType.number:
            props.type = props.uisubtype;
            view = renderNumber.call(this, options);
            break;
        case FormItemType.currency:
            props.type = props.uisubtype;
            view = renderNumber.call(this, options);
            break;
        case FormItemType.inputrefer:
            view = renderInputRefer.call(this, options);
            break;
        case FormItemType.date:
            view = renderDate.call(this, options);
            break;
        case FormItemType.switch:
            view = renderSwitch.call(this, options);
            break;
        case FormItemType.enumselect:
            view = renderEnumSelect.call(this, options);
            break;
        case FormItemType.cascader:
            view = renderCascader.call(this, options);
            break;
        case FormItemType.attachupload:
            view = renderAttachUpload.call(this, options);
            break;
        case FormItemType.time:
            view = renderTimePicker.call(this, options);
            break;
        default:
            view = renderInput.call(this, options);
    }
    //获取单元格错误消息，如果存在则追加错误消息图标
    errorMsg = this.getCellError({ rowId: rowData[rowKey], dataIndex: props.dataIndex });
    if (errorMsg) {
        errorMsg = React.createElement(YYIcon, { type: 'cross-circle', style: { color: '#f50' }, title: errorMsg });
    }
    if (editable !== false && rowData.isEdit && options.props.editable !== false) {
        //编辑态显示
        //显示编辑时的辅助提示信息
        if (options.props.editTip) {
            cellEditTip = React.createElement(
                YYTooltip,
                { title: options.props.editTip },
                React.createElement(YYIcon, { type: 'question-circle-o' })
            );
        }
        //启用单元格填充处理
        if (options.props.cellFill == true) {
            var fillMenu = React.createElement(
                YYMenu,
                { onClick: menuClickColumnCellFill.bind(this, { props: options.props, value: value, rowData: rowData, index: index }) },
                React.createElement(
                    YYMenuItem,
                    { key: 'cellFillToAll' },
                    '\u6574\u5217\u586B\u5145'
                ),
                React.createElement(
                    YYMenuItem,
                    { key: 'cellFillToUp' },
                    '\u5411\u4E0A\u586B\u5145'
                ),
                React.createElement(
                    YYMenuItem,
                    { key: 'cellFillToDown' },
                    '\u5411\u4E0B\u586B\u5145'
                )
            );
            //追加填充下拉菜单
            cellFillView = React.createElement(
                YYDropdown,
                { overlay: fillMenu },
                React.createElement(YYIcon, { type: 'copy' })
            );
        } else {}
    } else {} //非编辑态显示

    //存在错误图标、填充图标、帮助图标则使用wrapper
    if (errorMsg || cellFillView || cellEditTip) {
        view = React.createElement(
            'div',
            { className: 'yyui-table-cell-wrapper' },
            errorMsg,
            view,
            cellFillView,
            cellEditTip
        );
    }
    //回调renderAfter事件
    if (_.isFunction(props.renderAfter)) {
        view = props.renderAfter.call(this, { props: options.props, value: view, isEdit: rowData.isEdit, rowData: rowData, index: index, editable: editable });
    }
    return view;
}
//点击下拉菜单进行单元格填充
function menuClickColumnCellFill(options, menuInfo) {
    var props = options.props,
        value = options.value,
        rowData = options.rowData,
        index = options.index;

    var editTable = this;
    var rowKey = editTable.props.rowKey;
    var callback = null;
    if (menuInfo.key == 'cellFillToAll') {
        //整列填充
        editTable.saveColumnData(props.dataIndex, value, callback);
    } else if (menuInfo.key == 'cellFillToUp') {
        //向上填充
        editTable.saveColumnDataFillUp(rowData[rowKey], props.dataIndex, value, callback);
    } else if (menuInfo.key == 'cellFillToDown') {
        //向下填充
        editTable.saveColumnDataFillDown(rowData[rowKey], props.dataIndex, value, callback);
    }
}

//可编辑表格模板页面
var EditTableWidget = YYClass.create({
    //添加一行数据到首行，当rowData为数组时则进行批量添加
    addRow: function addRow(rowData, callback) {
        this.refs.editTableWidget.addRow(rowData, callback);
    },
    //添加一行数据到尾行，当rowData为数组时则进行批量添加
    addRowLast: function addRowLast(rowData, callback) {
        this.refs.editTableWidget.addRowLast(rowData, callback);
    },
    //插入新一行到指定行id的前面，当rowData为数组时则进行批量添加
    addRowBefore: function addRowBefore(options) {
        this.refs.editTableWidget.addRowBefore(options);
    },
    //插入新一行到指定行id的后面，当rowData为数组时则进行批量添加
    addRowAfter: function addRowAfter(options) {
        this.refs.editTableWidget.addRowAfter(options);
    },
    //删除指定的行数据，当rowKey为array[string]时则批量删除。
    delRow: function delRow(rowKey, callback) {
        this.refs.editTableWidget.delRow(rowKey, callback);
    },
    //将指定行启用为编辑
    editRow: function editRow(rowIndex) {
        console.error('本方法已过期，请使用editRowData(rowKey)方法');
    },
    //依据指定行的键值，将其设置为编辑态，rowKey-行键值
    editRowData: function editRowData(rowKey, callback) {
        this.refs.editTableWidget.editRowData(rowKey, callback);
    },
    //将指定行保存为非编辑
    saveRow: function saveRow(rowIndex, rowData, callback) {
        console.error('本方法已过期，请使用saveRowData(rowData)方法');
    },
    //依据rowKey匹配进行保存为非编辑
    saveRowData: function saveRowData(rowData, callback) {
        this.refs.editTableWidget.saveRowData(rowData, callback);
    },
    //将指定行对应单元格数据进行保存
    saveCell: function saveCell(rowIndex, dataIndex, cellValue, callback) {
        console.error('本方法已过期，请使用saveCellData(rowKey,dataIndex,cellValue)方法');
    },
    //将指定行键值对应单元格数据进行保存
    saveCellData: function saveCellData(rowKey, dataIndex, cellValue, callback) {
        this.refs.editTableWidget.saveCellData(rowKey, dataIndex, cellValue, callback);
    },
    /**
     * 更新指定列下的单元格值
     * @param dataIndex 列数据索引名
     * @param cellValue 单元格更新后的值
     * @param callback 更新后的回调
     */
    saveColumnData: function saveColumnData(dataIndex, cellValue, callback) {
        this.refs.editTableWidget.saveColumnData(dataIndex, cellValue, callback);
    },
    /**
     * 从指定行开始向上更新指定列下的单元格值
     * @param rowId 当更新方式为 up|down 时，必须指定此参数值
     * @param dataIndex 列数据索引名
     * @param cellValue 单元格更新后的值
     * @param callback 更新后的回调
     */
    saveColumnDataFillUp: function saveColumnDataFillUp(rowId, dataIndex, cellValue, callback) {
        this.refs.editTableWidget.saveColumnDataFillUp(dataIndex, cellValue, callback);
    },
    /**
     * 从指定行开始向下更新指定列下的单元格值
     * @param rowId 当更新方式为 up|down 时，必须指定此参数值
     * @param dataIndex 列数据索引名
     * @param cellValue 单元格更新后的值
     * @param callback 更新后的回调
     */
    saveColumnDataFillDown: function saveColumnDataFillDown(rowId, dataIndex, cellValue, callback) {
        this.refs.editTableWidget.saveColumnDataFillDown(dataIndex, cellValue, callback);
    },
    //清除所有行数据
    clearRowData: function clearRowData(callback) {
        this.refs.editTableWidget.clearRowData(callback);
    },
    //移动行数据
    rowMoveTo: function rowMoveTo(options) {
        this.refs.editTableWidget.rowMoveTo(options);
    },
    //清除行编辑态
    clearEditAll: function clearEditAll(callback) {
        this.refs.editTableWidget.clearEditAll(callback);
    },
    /**
     * 获取当前数据源
     */
    getDataSource: function getDataSource(options) {
        return this.refs.editTableWidget.getDataSource(options);
    },
    /**
     * 获取当前全部行数据
     * @param rowState "all"|"add"|"edit"|"del"|"old"，获取指定状态的行数据，不指定则默认"all"获取全部状态行
     * @param clearIsEdit 是否清除掉编辑态，默认true，如果不需要清除则设置为false
     * @param clearNewId 是否清除掉新增数据时生成的主键值，默认true
     */
    getRowData: function getRowData(options) {
        return this.refs.editTableWidget.getRowData(options);
    },
    /**
     * 获取当前选中行的数据
     * @param clearNewId 是否清除掉新增数据时生成的主键值，默认true
     */
    getSelectedRowData: function getSelectedRowData(options) {
        return this.refs.editTableWidget.getSelectedRowData(options);
    },
    //获取当前选中的行keys
    getSelectedRowKeys: function getSelectedRowKeys() {
        return this.refs.editTableWidget.getSelectedRowKeys();
    },
    //通过rowKey获取指定rowData
    getRowDataByKey: function getRowDataByKey(options) {
        return this.refs.editTableWidget.getRowDataByKey(options);
    },
    //通过rowKey, dataIndex获取指定cellData
    getCellDataByKey: function getCellDataByKey(options) {
        return this.refs.editTableWidget.getCellDataByKey(options);
    },
    //清除勾选状态
    clearSelectedRowKeys: function clearSelectedRowKeys() {
        return this.refs.editTableWidget.clearSelectedRowKeys();
    },
    //获取已删除行的行keys
    getDeleteRowKeys: function getDeleteRowKeys() {
        return this.refs.editTableWidget.getDeleteRowKeys();
    },
    //获取所有单元格的错误消息
    getAllCellError: function getAllCellError() {
        return this.refs.editTableWidget.getAllCellError();
    },
    //设置所有单元格的错误消息
    setAllCellError: function setAllCellError(cellErrors) {
        this.refs.editTableWidget.setAllCellError(cellErrors);
    },
    //添加一个新的单元格错误消息，不会刷新，需要手动刷新。
    addCellError: function addCellError(cellErrors, options) {
        return this.refs.editTableWidget.addCellError(cellErrors, options);
    },
    //清除指定单元格的错误消息
    clearCellError: function clearCellError(options) {
        this.refs.editTableWidget.clearCellError(options);
    },
    //设置指定单元格的错误消息，立即刷新
    setCellError: function setCellError(options) {
        this.refs.editTableWidget.setCellError(options);
    },
    //获取指定单元格的错误消息
    getCellError: function getCellError(options) {
        return this.refs.editTableWidget.getCellError(options);
    },
    /**
     * 进行必填、正则的校验
     * @return
     *  全部验证通过返回true
     *  否则返回全部错误信息，内容格式参看getAllCellError()方法返回的格式。
     */
    validate: function validate() {
        var _this = this;

        this.setAllCellError(null); //清除历史错误消息
        var cellErrors = {};
        var dataSource = this.getRowData({ clearNewId: false, clearDel: true });
        var columns = this.props.children;
        var rowKey = this.props.rowKey;
        _.forEach(dataSource, function (rowData) {
            for (var index = 0; index < columns.length; index++) {
                var column = columns[index];
                var columnProps = React.isValidElement(column) ? column.props : column;
                var cellData = rowData[columnProps.dataIndex];
                // 该列配置了验证规则
                if (columnProps.required == true) {
                    if (cellData === null || cellData === '' || cellData === undefined) {
                        _this.addCellError(cellErrors, {
                            rowId: rowData[rowKey],
                            dataIndex: columnProps.dataIndex,
                            errorMsg: '此项必须填写'
                        });
                        continue;
                    }
                }
                if (columnProps.pattern) {
                    var regexp = new RegExp(columnProps.pattern);
                    if (!regexp.test(cellData)) {
                        _this.addCellError(cellErrors, {
                            rowId: rowData[rowKey],
                            dataIndex: columnProps.dataIndex,
                            errorMsg: columnProps.patternMsg
                        });
                    }
                }
            }
        });
        if (_.isEmpty(cellErrors)) {
            return true;
        } else {
            this.setAllCellError(cellErrors);
            return cellErrors;
        }
    },
    //渲染列定义
    _renderColumns: function _renderColumns() {
        var columns = [];
        var children = this.props.children;
        var rowKey = this.props.rowKey;
        if (children) {
            if (_.isArray(children) && children.length > 0) {
                _.forEach(children, function (child, index) {
                    if (React.isValidElement(child)) {
                        var _render = function _render(value, rowData, index) {
                            return doCellRender.call(this, child.props, value, rowData, index, rowKey);
                        };
                        //存在自定义render则绑定自定义行为，否则走默认行为
                        var render = child.props && child.props.render ? child.props.render : _render;
                        var column = _.assign({}, child.props, {
                            key: child.key,
                            render: render
                        });
                        //如果不存在column.fieldtype值则依据uisubtype配置column.fieldtype值
                        if (!column.fieldtype) {
                            switch (child.props.uisubtype) {
                                case FormItemType.number:
                                    column.fieldtype = "number";break;
                                case FormItemType.currency:
                                    column.fieldtype = "currency";break;
                                case FormItemType.date:
                                    column.fieldtype = "date";break;
                                case FormItemType.switch:
                                    column.fieldtype = "boolean";break;
                            }
                            column.fieldtype = column.fieldtype || child.props.uisubtype;
                        }
                        columns.push(column);
                    }
                });
            }
        }
        return columns;
    },
    render: function render() {
        var columns = this._renderColumns(this.props.children);
        return React.createElement(YYEditTable, _extends({}, this.props, { ref: 'editTableWidget', columns: columns, children: null }));
    }
});
module.exports = EditTableWidget;