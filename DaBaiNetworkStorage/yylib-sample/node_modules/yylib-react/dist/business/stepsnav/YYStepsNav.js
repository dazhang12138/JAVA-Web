'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

/**
* 步骤条导航组件
*/
var React = require('react');

var _require = require('yylib-ui'),
    YYClass = _require.YYClass,
    YYSteps = _require.YYSteps,
    YYStep = _require.YYStep,
    YYNavItem = _require.YYNavItem;

var _require2 = require('react-dom'),
    findDOMNode = _require2.findDOMNode;

var PropTypes = YYClass.PropTypes;
var field = YYClass.field;
var _ = require('lodash');
require('./index.less');
var EXTRAHEIGHT = 0;
//定义META
var uiMeta = {
    name: 'stepsnav',
    fields: [
    // field参数列表：字段属性名|属性默认值|属性类型|是否必填|属性描述
    field('items', null, PropTypes.object, true, '步骤条数据来源{className:页面定位元素类名(唯一)，title:标题,description:详情描述}'), field('target', null, PropTypes.string, false, '设置导航栏需要监听其滚动事件的元素，值为一个返回对应 DOM 元素的函数')]
};
var YYStepsNav = YYClass.create({
    uiMeta: uiMeta,
    getInitialState: function getInitialState() {
        return {
            hasMove: false,
            current: 0,
            nodeHeight: 0 // 步骤条高度
            // _target:this._getTarget()
        };
    },
    //  获取监听滚动事件DOM
    _getTarget: function _getTarget() {
        // 自定义页面时，设计态采用画布，开发态，采用body
        // 建造卡片页面，设计态，开发态均采用cp2-page-card
        var _target = null;
        var target = this.props.target;
        var targetDom = target && document.querySelector('.' + target) ? document.querySelector('.' + target) : null;
        var card = document.querySelector('.cp2-page-card');
        var canvas = document.querySelector('.dev-design-canvas');
        var body = document.body;
        var arrDom = [targetDom, card, canvas, body]; // 可能的target节点
        var arrScroll = _.map(arrDom, function (dom) {
            // 返回dom元素总高度
            if (dom && dom.scrollHeight) {
                return dom.scrollHeight;
            }
        });
        var MAXSCROLLHEIGHT = _.max(arrScroll);
        var _targetArr = _.filter(arrDom, function (dom) {
            //  过滤掉不可能的dom节点
            if (dom && dom.scrollHeight === MAXSCROLLHEIGHT) {
                return dom;
            }
        });
        //  数组判断
        if (_.isEmpty(_targetArr) || !_targetArr) {
            _target = document.body;
        } else if (_targetArr.length === 1) {
            _target = _targetArr[0];
        } else if (_targetArr.length > 1) {
            _target = document.body;
        }
        return _target;
    },
    _onscroll: function _onscroll() {
        var _this = this;

        var _target = this._getTarget();
        this._setFixedHeight(_target);
        var scrollTop = _target.scrollTop || document.documentElement.scrollTop; // 滚动距离
        var items = this.props.items ? this.props.items : this.props.children; // items优先于children
        var targetTop = _target.isEqualNode(document.body) ? 0 : _target.getBoundingClientRect().top;
        var arr = _.map(items, function (item) {
            // 记录子元素距离顶部的距离
            var child = React.isValidElement(item) ? item.props : item;
            var node = child.linkTarget ? document.querySelector('.' + child.linkTarget) : null;
            if (node) {
                return node.getBoundingClientRect().top + window.pageYOffset - document.documentElement.clientTop + EXTRAHEIGHT;
            }
        });
        _.forEach(arr, function (item, index) {
            var top = item - arr[0] - targetTop;
            if (scrollTop >= top) {
                _this.setState({
                    current: index
                });
            }
        });
    },
    _setFixedHeight: function _setFixedHeight(_target) {
        // 目前仅考虑在顶部的情况
        // this.extraHeight = 0;
        var fixedDOM = _target.querySelector('.yyui-affix');
        EXTRAHEIGHT = fixedDOM && fixedDOM.clientHeight ? fixedDOM.clientHeight : 0;
        // if(fixedDOM&&header.style&&header.style.top === '0px'){
        //     // console.log('header.clientHeight',header.clientHeight);
        //     EXTRAHEIGHT = header.clientHeight
        // }
    },
    //  事件注册
    componentDidMount: function componentDidMount() {
        var _this2 = this;

        var _target = this._getTarget();
        var node = findDOMNode(this);
        this.setState({
            nodeHeight: node.clientHeight
        }, function () {
            _this2._setPosition(_this2.state.nodeHeight);
        });
        // if (_target.addEventListener) {
        //     _target.addEventListener("mousewheel", this._onscroll, true);
        // } else {
        //     _target.attachEvent("mousewheel", this._onscroll);
        // }
        _target.onscroll = this._onscroll;
    },
    componentWillUpdate: function componentWillUpdate() {
        this._setPosition(this.state.nodeHeight);
        var _target = this._getTarget();
        this._setFixedHeight(_target);
    },
    _clickStep: function _clickStep(key, target) {
        var _target = this._getTarget();
        var targetTop = _target.isEqualNode(document.body) ? 0 : _target.getBoundingClientRect().top;
        var targetDom = target ? document.querySelector('.' + target) : null;
        var scrollTop = _target.scrollTop || document.documentElement.scrollTop; // 滚动距离
        _target.scrollTop = targetDom ? targetDom.getBoundingClientRect().top + scrollTop - _target.clientTop - targetTop - EXTRAHEIGHT : 0;
        if (_target === document.body) {
            document.documentElement.scrollTop = targetDom ? targetDom.getBoundingClientRect().top + scrollTop - _target.clientTop - targetTop - EXTRAHEIGHT : 0;
        }
        this.setState({
            current: key
        });
    },
    mouseIn: function mouseIn() {
        this.setState({
            hasMove: true
        });
    },
    // 处理页面大小变化时的样式问题
    _setPosition: function _setPosition(nodeHeight) {
        var right, top;
        var SCROLLWIDTH = 17; // 页面滚动条宽度
        var node = findDOMNode(this);
        var _target = this._getTarget();
        var isWindow = _target.isEqualNode(document.body);
        var _targetRect = _target.getBoundingClientRect();
        if (isWindow) {
            top = (document.body.clientHeight - EXTRAHEIGHT - nodeHeight) / 2;
            right = 0;
        } else {
            top = (_target.clientHeight - nodeHeight) / 2 + _targetRect.top;
            right = window.innerWidth - _targetRect.right + SCROLLWIDTH;
        }
        if (!node.style) {
            node.style = {};
        };
        _.assign(node.style, {
            right: right + 'px',
            top: top + 'px'
        });
    },
    mouseOut: function mouseOut() {
        this.setState({
            hasMove: false
        });
    },
    _getSteps: function _getSteps() {
        var _this3 = this;

        var hasMove = this.state.hasMove;
        var items = this.props.items ? this.props.items : this.props.children;
        var that = this;
        var steps = _.map(items, function (item, index) {
            var child = React.isValidElement(item) ? item.props : item;
            var linkTarget = child.linkTarget,
                title = child.title,
                description = child.description,
                icon = child.icon,
                iconText = child.iconText,
                status = child.status;

            if (!_this3.props.noDirection) {
                return React.createElement(YYStep, { icon: icon, title: React.createElement(
                        'span',
                        { style: { cursor: 'pointer' }, onClick: that._clickStep.bind(that, index, linkTarget) },
                        hasMove ? title : ''
                    ), description: hasMove ? description : '' });
            } else {
                return React.createElement(YYNavItem, { icon: icon,
                    isLast: index == items.length - 1,
                    iconText: iconText,
                    status: status,
                    title: React.createElement(
                        'span',
                        { style: { cursor: 'pointer' }, onClick: that._clickStep.bind(that, index, linkTarget) },
                        hasMove ? title : ''
                    ),
                    description: hasMove ? description : '' });
            }
        });
        return steps;
    },
    // 事件注销
    componentWillUnmount: function componentWillUnmount() {
        var _target = this._getTarget();
        // if(_target.addEventListener){
        //     _target.removeEventListener("mousewheel",this._onscroll,true);
        // }else{
        //     _target.detachEvent("mousewheel", this._onscroll);
        // }
        delete _target.onscroll;
    },
    render: function render() {
        var cls = this.className() + (this.state.hasMove ? " expended" : "");
        return React.createElement(
            'div',
            {
                onMouseOver: this.mouseIn,
                onMouseOut: this.mouseOut,
                className: cls
            },
            React.createElement(
                YYSteps,
                _extends({}, this.props, {
                    direction: 'vertical',
                    size: 'small',
                    current: this.state.current
                }),
                this._getSteps()
            )
        );
    }
});
module.exports = YYStepsNav;