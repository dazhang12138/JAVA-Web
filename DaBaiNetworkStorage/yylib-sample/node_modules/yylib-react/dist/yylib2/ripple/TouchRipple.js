'use strict';

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/**
 * @copyright material-ui
 */
var React = require('react');
var YYClass = require('../base/YYClass');
var PropTypes = YYClass.PropTypes;
var field = YYClass.field;

var _require = require('react-dom'),
    findDOMNode = _require.findDOMNode;

var ReactTransitionGroup = require('react-addons-transition-group');
var CircleRipple = require('./CircleRipple');

var uiMeta = {
  name: 'touchripple',
  fields: [
  // field参数列表：字段属性名|属性默认值|属性类型|是否必填|属性描述
  field('abortOnScroll', true, PropTypes.bool, false, '指定当前是否选中'), field('centerRipple', false, PropTypes.bool, false, '是否将波纹放在中心'), field('children', null, PropTypes.node, true, '子组件'), field('color', null, PropTypes.string, true, '波纹颜色'), field('opacity', null, PropTypes.number, true, '波纹透明度'), field('style', null, PropTypes.object, true, '波纹样式')]
};

var TouchRipple = YYClass.create({
  uiMeta: uiMeta,
  getInitialState: function getInitialState() {
    this.ignoreNextMouseDown = false;
    return {
      hasRipples: false,
      nextKey: 0,
      ripples: []
    };
  },
  start: function start(event, isRippleTouchGenerated) {

    if (this.ignoreNextMouseDown && !isRippleTouchGenerated) {
      this.ignoreNextMouseDown = false;
      return;
    }

    var ripples = this.state.ripples;

    // Add a ripple to the ripples array
    ripples = [].concat(_toConsumableArray(ripples), [React.createElement(CircleRipple, {
      key: this.state.nextKey,
      style: !this.props.centerRipple ? this.getRippleStyle(event) : {},
      color: this.props.color || '#999',
      opacity: this.props.opacity || 0.3,
      touchGenerated: isRippleTouchGenerated
    })]);

    this.ignoreNextMouseDown = isRippleTouchGenerated;
    this.setState({
      hasRipples: true,
      nextKey: this.state.nextKey + 1,
      ripples: ripples
    });
  },

  end: function end() {
    var currentRipples = this.state.ripples;
    currentRipples.shift();
    this.setState({
      ripples: currentRipples
    });
    if (this.props.abortOnScroll) {
      this.stopListeningForScrollAbort();
    }
  },

  handleMouseDown: function handleMouseDown(event) {
    // only listen to left clicks
    if (event.button === 0) {
      this.start(event, false);
    }
  },

  handleMouseUp: function handleMouseUp() {
    this.end();
  },

  handleMouseLeave: function handleMouseLeave() {
    this.end();
  },

  handleTouchStart: function handleTouchStart(event) {
    event.stopPropagation();
    // If the user is swiping (not just tapping), save the position so we can
    // abort ripples if the user appears to be scrolling.
    if (this.props.abortOnScroll && event.touches) {
      this.startListeningForScrollAbort(event);
      this.startTime = Date.now();
    }
    this.start(event, true);
  },

  handleTouchEnd: function handleTouchEnd() {
    this.end();
  },

  // Check if the user seems to be scrolling and abort the animation if so
  handleTouchMove: function handleTouchMove(event) {
    var _this = this;

    // Stop trying to abort if we're already 300ms into the animation
    var timeSinceStart = Math.abs(Date.now() - this.startTime);
    if (timeSinceStart > 300) {
      this.stopListeningForScrollAbort();
      return;
    }

    // If the user is scrolling...
    var deltaY = Math.abs(event.touches[0].clientY - this.firstTouchY);
    var deltaX = Math.abs(event.touches[0].clientX - this.firstTouchX);
    // Call it a scroll after an arbitrary 6px (feels reasonable in testing)
    if (deltaY > 6 || deltaX > 6) {
      var currentRipples = this.state.ripples;
      var ripple = currentRipples[0];
      // This clone will replace the ripple in ReactTransitionGroup with a
      // version that will disappear immediately when removed from the DOM
      var abortedRipple = React.cloneElement(ripple, { aborted: true });
      // Remove the old ripple and replace it with the new updated one

      currentRipples.shift();
      currentRipples = [].concat(_toConsumableArray(currentRipples), [abortedRipple]);
      this.setState({ ripples: currentRipples }, function () {
        // Call end after we've set the ripple to abort otherwise the setState
        // in end() merges with this and the ripple abort fails
        _this.end();
      });
    }
  },

  startListeningForScrollAbort: function startListeningForScrollAbort(event) {
    this.firstTouchY = event.touches[0].clientY;
    this.firstTouchX = event.touches[0].clientX;
    // Note that when scolling Chrome throttles this event to every 200ms
    // Also note we don't listen for scroll events directly as there's no general
    // way to cover cases like scrolling within containers on the page
    document.body.addEventListener('touchmove', this.handleTouchMove);
  },

  stopListeningForScrollAbort: function stopListeningForScrollAbort() {
    document.body.removeEventListener('touchmove', this.handleTouchMove);
  },

  getRippleStyle: function getRippleStyle(event) {
    var style = {};
    var el = findDOMNode(this);
    var elHeight = el.offsetHeight;
    var elWidth = el.offsetWidth;
    var rect = el.getBoundingClientRect();
    var offset = {
      top: rect.top + document.body.scrollTop,
      left: rect.left + document.body.scrollLeft
    };
    //计算点击处到四角的距离
    var isTouchEvent = event.touches && event.touches.length;
    var pageX = isTouchEvent ? event.touches[0].pageX : event.pageX;
    var pageY = isTouchEvent ? event.touches[0].pageY : event.pageY;
    var pointerX = pageX - offset.left;
    var pointerY = pageY - offset.top;
    var topLeftDiag = this.calcDiag(pointerX, pointerY);
    var topRightDiag = this.calcDiag(elWidth - pointerX, pointerY);
    var botRightDiag = this.calcDiag(elWidth - pointerX, elHeight - pointerY);
    var botLeftDiag = this.calcDiag(pointerX, elHeight - pointerY);
    var rippleRadius = Math.max(topLeftDiag, topRightDiag, botRightDiag, botLeftDiag);
    var rippleSize = rippleRadius * 2;
    var left = pointerX - rippleRadius;
    var top = pointerY - rippleRadius;

    style.height = rippleSize + 'px';
    style.width = rippleSize + 'px';
    style.top = top + 'px';
    style.left = left + 'px';

    return style;
  },

  calcDiag: function calcDiag(a, b) {
    return Math.sqrt(a * a + b * b);
  },

  render: function render() {
    var _props = this.props,
        children = _props.children,
        style = _props.style;
    var _state = this.state,
        hasRipples = _state.hasRipples,
        ripples = _state.ripples;


    var rippleGroup = void 0;

    if (hasRipples) {
      var mergedStyles = Object.assign({
        height: '100%',
        width: '100%',
        position: 'absolute',
        top: 0,
        left: 0,
        overflow: 'hidden'
      }, style);

      rippleGroup = React.createElement(
        ReactTransitionGroup,
        { style: mergedStyles },
        ripples
      );
    }

    return React.createElement(
      'div',
      {
        onMouseUp: this.handleMouseUp,
        onMouseDown: this.handleMouseDown,
        onMouseLeave: this.handleMouseLeave,
        onTouchStart: this.handleTouchStart,
        onTouchEnd: this.handleTouchEnd
      },
      rippleGroup,
      children
    );
  }
});

module.exports = TouchRipple;