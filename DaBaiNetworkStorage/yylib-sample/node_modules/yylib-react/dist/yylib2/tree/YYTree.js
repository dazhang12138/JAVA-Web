'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

/**
 * 树形组件
 */
var React = require('react');

var _require = require('react-dom'),
    findDOMNode = _require.findDOMNode;

var YYClass = require('../base/YYClass');
var PropTypes = YYClass.PropTypes;
var field = YYClass.field;

var _require2 = require('antd'),
    Tree = _require2.Tree;

var YYTreeNode = require('./YYTreeNode');
var _ = require('lodash');
var YYInputButton = require('../formcontrols/inputbutton/YYInputButton');
var ReactUtils = require('../../utils/ReactUtils');
var TreeNodeOverride = require('./TreeNodeOverride');
var YYSpin = require('../spin/YYSpin');
var YYTreeSearchTrigger = require('./YYTreeSearchTrigger');
TreeNodeOverride();
require('./style/index.less');
//定义META
var uiMeta = {
    name: 'tree',
    fields: [field('multiple', false, PropTypes.bool, false, '是否支持选中多项，控制selected状态'), field('header', null, PropTypes.element, false, '头部标题内容'), field('bordered', false, PropTypes.bool, false, '是否展示外边框'), field('checkable', false, PropTypes.bool, false, '是否支持勾选模式，控制checked状态'), field('defaultExpandAll', false, PropTypes.bool, false, '默认展开所有树节点'), field('defaultExpandedKeys', undefined, PropTypes.arrayOf(PropTypes.string), false, '默认展开指定的树节点'), field('expandedKeys', undefined, PropTypes.arrayOf(PropTypes.string), false, '（受控）展开指定的树节点'), field('autoExpandParent', true, PropTypes.bool, false, '是否自动展开父节点，注意：如果没有设置autoExpandParent=false,当子节点被展开时，父节点将不能被折叠'), field('defaultCheckedKeys', undefined, PropTypes.arrayOf(PropTypes.string), false, '默认选中复选框的树节点'), field('checkedKeys', undefined, PropTypes.arrayOf(PropTypes.string), false, '（受控）选中复选框的树节点'), field('checkStrictly', false, PropTypes.bool, false, 'checkable状态下节点选择完全受控（父子节点选中状态不再关联）'), field('defaultSelectedKeys', undefined, PropTypes.arrayOf(PropTypes.string), false, '默认选中的树节点'), field('selectedKeys', undefined, PropTypes.arrayOf(PropTypes.string), false, '（受控）设置选中的树节点'), field('onExpand', null, PropTypes.func, false, '展开/收起节点时触发'), field('onCheck', null, PropTypes.func, false, '点击复选框触发'), field('onSelect', null, PropTypes.func, false, '点击树节点触发')
    //,field('filterTreeNode',null,PropTypes.func,false,'按需筛选树节点（高亮），返回true')
    , field('loadData', null, PropTypes.func, false, '异步加载数据'), field('onRightClick', null, PropTypes.func, false, '响应节点右键点击'), field('onNodeDblClick', null, PropTypes.func, false, '响应节点双击点击，传递参数:nodeKey-当前节点key、e:{event:"dblclick",node:react组件}'), field('draggable', false, PropTypes.bool, false, '设置节点可拖拽（IE>8）'), field('onDragStart', null, PropTypes.func, false, '开始拖拽时调用'), field('onDragEnter', null, PropTypes.func, false, 'dragenter 触发时调用'), field('onDragOver', null, PropTypes.func, false, 'dragover 触发时调用'), field('onDragLeave', null, PropTypes.func, false, 'dragleave 触发时调用'), field('onDrop', null, PropTypes.func, false, 'drop 触发时调用'), field('showLine', false, PropTypes.bool, false, '是否显示对齐边线'), field('nodes', undefined, PropTypes.array, false, '数据源'), field('searchFilter', false, PropTypes.bool, false, '是否启用搜索过滤功能'), field('searchAddonBefore', undefined, PropTypes.any, false, '搜索输入框的前置内容，只有当searchFilter=true时才能生效'), field('searchMode', undefined, PropTypes.string, false, '搜索输入框的类型，只有当searchFilter=true时才能生效, default或dropdown'), field('loading', false, PropTypes.bool, false, '页面是否加载中'), field('emptyView', null, PropTypes.element, false, '当树节点为空时，显示的内容'), field('placeholder', '请输入搜索关键词', PropTypes.string, false, '搜索框的提示信息'), field('height', null, PropTypes.string, false, '设置树的内容体固定高度')]
    //匹配节点标题是否包含指定的文本
};function matchTreeNodeText(treeNode, searchText) {
    if (treeNode && treeNode.props && searchText && searchText.length > 0) {
        //获取节点标题中的所有文本（支持对react对象类型标题的解析）
        var results = ReactUtils.getChildrenText(treeNode.props.title);
        var text = results.join();
        return text.indexOf(searchText) >= 0;
    }
    return false;
}
//依据JSON数据生成树节点元素
function generateTreeNodes(data) {
    console.log('data', data);
    if (!data || data.length === 0) {
        return;
    }
    return data.map(function (item) {
        if (item.children) {
            return React.createElement(
                YYTreeNode,
                item,
                generateTreeNodes(item.children)
            );
        }
        return React.createElement(YYTreeNode, item);
    });
}

function generateNodesDataFromChildren(children, parentText) {
    var nodes = [];
    //如果是对象 先转成数组再进行解析
    if (_.isPlainObject(children)) {
        children = [children];
    }
    _.forEach(children, function (treeNode, index, arr) {
        var text = treeNode.props.title;
        if (parentText) {
            text = parentText + ' / ' + treeNode.props.title;
        }
        nodes.push({
            key: treeNode.key,
            title: text
        });
        if (React.isValidElement(treeNode)) {
            //text作为parentText 传到子节点的循环中，拼接到title中
            nodes = nodes.concat(generateNodesDataFromChildren(treeNode.props.children, text));
        }
    });
    return nodes;
}
var YYTree = YYClass.create({
    uiMeta: uiMeta,
    getInitialState: function getInitialState() {
        //存在expandedKeys则优先使用expandedKeys，否则使用defaultExpandedKeys
        var expandedKeys = this.props.expandedKeys ? this.props.expandedKeys : this.props.defaultExpandedKeys;
        var checkedKeys = this.props.checkedKeys ? this.props.checkedKeys : this.props.defaultCheckedKeys;
        var selectedKeys = this.props.selectedKeys ? this.props.selectedKeys : this.props.defaultSelectedKeys;
        return {
            expandedKeys: expandedKeys,
            checkedKeys: checkedKeys,
            selectedKeys: selectedKeys,
            searchFilterKey: '',
            searchExpandedKeys: [],
            loading: this.props.loading
        };
    },
    _refTree: null //当前树实例
    , getChildContext: function getChildContext() {
        return {
            onNodeDblClick: this.handleDblClick
        };
    },
    handleDblClick: function handleDblClick(dblKey, event) {
        if (_.isFunction(this.props.onNodeDblClick)) {
            this.props.onNodeDblClick(dblKey, event);
        }
    }
    //当相关键值发生变更时的处理，处理expandedKeys、checkedKeys、selectedKeys
    , _onKeysChange: function _onKeysChange(nextProps) {
        if ('defaultExpandedKeys' in nextProps) {
            if (!ReactUtils.isArrayEqual(this.props.defaultExpandedKeys, nextProps.defaultExpandedKeys)) {
                this.setState({ expandedKeys: nextProps.defaultExpandedKeys });
            }
        }
        //expandedKeys优先级高于defaultExpandedKeys
        if ('expandedKeys' in nextProps) {
            // if(!ReactUtils.isArrayEqual(this.props.expandedKeys,nextProps.expandedKeys)) {
            this.setState({ expandedKeys: nextProps.expandedKeys });
            // }
        }
        if ('defaultCheckedKeys' in nextProps) {
            if (!ReactUtils.isArrayEqual(this.props.defaultCheckedKeys, nextProps.defaultCheckedKeys)) {
                this.setState({ checkedKeys: nextProps.defaultCheckedKeys });
            }
        }
        //checkedKeys优先级高于defaultCheckedKeys
        if ('checkedKeys' in nextProps) {
            //if(!ReactUtils.isArrayEqual(this.props.checkedKeys,nextProps.checkedKeys)) {
            this.setState({ checkedKeys: nextProps.checkedKeys });
            //}
        }
        if ('defaultSelectedKeys' in nextProps) {
            if (!ReactUtils.isArrayEqual(this.props.defaultSelectedKeys, nextProps.defaultSelectedKeys)) {
                this.setState({ selectedKeys: nextProps.defaultSelectedKeys });
            }
        }
        //selectedKeys优先级高于defaultSelectedKeys
        if ('selectedKeys' in nextProps) {
            // 2017.02.20 by zhangzhzhc 树表参照左树需要有默认选中的节点，当取消默认节点选择时，此处条件使默认节点无法选中，所以注释掉
            // if(!ReactUtils.isArrayEqual(this.props.selectedKeys,nextProps.selectedKeys)) {
            this.setState({ selectedKeys: nextProps.selectedKeys });
            // }
        }
    },
    componentDidMount: function componentDidMount() {
        this._updateTreeHeight(this.props.height);
    }
    //更新树内容体的固定高度
    , _updateTreeHeight: function _updateTreeHeight(height) {
        if (this._refTree && height) {
            var treeDom = findDOMNode(this._refTree);
            treeDom.style.height = parseInt(height) + 'px';
        }
    },
    componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
        //处理expandedKeys、checkedKeys、selectedKeys
        this._onKeysChange(nextProps);
        if ('loading' in nextProps) {
            if (!this.props.loading === nextProps.loading) {
                this.setState({ loading: nextProps.loading });
            }
        }
        if ('autoExpandParent' in nextProps) {
            this.setState({ autoExpandParent: nextProps.autoExpandParent });
        }
        if ('checkStrictly' in nextProps && this.props.checkStrictly !== nextProps.checkStrictly) {
            this.setState({ checkedKeys: [] });
        }
        if (this.props.height !== nextProps.height) {
            this._updateTreeHeight(nextProps.height);
        }
    }
    //当节点被展开|折叠时触发
    , _onExpandTreeNode: function _onExpandTreeNode(expandedKeys, expandNode) {
        // 如果没有设置 autoExpandParent = false, 当子节点 children 被展开时，父节点 parent 将不能被折叠.
        // 或者, 自行控制移除掉所有被展开的子节点的keys.
        this.setState({
            expandedKeys: expandedKeys //常规被展开的节点keys
            , searchExpandedKeys: [] //搜索过滤后需要展开的节点keys
            , lastSearchText: this.state.searchFilterKey //最后一次搜索的关键词
            , autoExpandParent: false
        });
        if (_.isFunction(this.props.onExpand)) {
            this.props.onExpand(expandedKeys, expandNode);
        }
    }
    //当节点被选择|取消时触发
    , _onSelectTreeNode: function _onSelectTreeNode(selectedKeys, e) {
        this.setState({ selectedKeys: selectedKeys });
        if (_.isFunction(this.props.onSelect)) {
            this.props.onSelect(selectedKeys, e);
        }
    }
    //当节点被勾选|取消时触发
    , _onCheckTreeNode: function _onCheckTreeNode(checkedKeys, e) {
        //antd里面存在bug：checkStrictly变更后checkedKeys.length>0，但值全部为undefined，所以进行下清理
        checkedKeys = _.filter(checkedKeys, function (o) {
            return o !== undefined;
        });
        this.setState({ checkedKeys: checkedKeys });
        if (_.isFunction(this.props.onCheck)) {
            this.props.onCheck(checkedKeys, e);
        }
    }
    //依据搜索输入框的条件过滤节点数据
    , _searchFilterNode: function _searchFilterNode(node) {
        var filter = matchTreeNodeText(node, this.state.searchFilterKey);
        return filter;
    }
    //当搜索输入框的值发生变更时
    , _searchFilterInputChange: function _searchFilterInputChange(event, value) {
        var that = this;
        var searchText = value ? value : event.target.value;
        //输入延迟刷新，避免连续输入时过多重复渲染
        clearTimeout(that._searchFilterTimeout);
        that._searchFilterTimeout = setTimeout(function () {
            that.setState({ lastSearchText: '', searchFilterKey: searchText, searchExpandedKeys: [],
                autoExpandParent: true //注意搜索结果默认展开父级
            });
        }, 500);
    }
    //当搜索输入框按钮点击时
    , _searchFilterInputClick: function _searchFilterInputClick(value) {
        clearTimeout(this._searchFilterTimeout); //清除计时器
        this.setState({ lastSearchText: '', searchFilterKey: value, searchExpandedKeys: [] });
    },
    render: function render() {
        var _this = this;

        //获取子节点元素
        var children = this.props.nodes ? generateTreeNodes(this.props.nodes) : this.props.children;
        //获取Tree的 defaultExpandedKeys，defaultSelectedKeys，defaultCheckedKeys与相应的TreeNode合并
        var _expandedKeys = this.state.expandedKeys ? this.state.expandedKeys : [];
        var _selectedKeys = this.state.selectedKeys ? this.state.selectedKeys : [];
        var _checkedKeys = this.state.checkedKeys ? this.state.checkedKeys : [];
        var searchExpandedKeys = this.state.searchExpandedKeys;
        var lastSearchText = this.state.lastSearchText; //最后搜索的关键词
        var searchFilterKey = this.state.searchFilterKey; //搜索筛选的关键词
        ReactUtils.loopAllChildren(children, function (item, index, pos, key, siblingPos, parent) {
            if (item.props.selected) {
                //子节点选中
                _selectedKeys.indexOf(item.key) === -1 ? _selectedKeys.push(item.key) : _selectedKeys;
            }
            if (item.props.expanded) {
                //子节点展开
                _expandedKeys.indexOf(item.key) === -1 ? _expandedKeys.push(item.key) : _expandedKeys;
            }
            if (item.props.checked) {
                //子节点勾选
                _checkedKeys.indexOf(item.key) === -1 ? _checkedKeys.push(item.key) : _checkedKeys;
            }
            //最后一次记录的关键词与当前关键词不一致则重新计算搜索展开的Key
            if (lastSearchText != searchFilterKey) {
                if (matchTreeNodeText(item, searchFilterKey)) {
                    //如果当前节点匹配，则默认展开
                    // var itemKeyArr = item.key.split('-');
                    // itemKeyArr.splice(itemKeyArr.length-1,1);//找到父级节点key，用于展开父级节点
                    // var parentItemKey = itemKeyArr.join('-');
                    if (parent && parent.node) {
                        var parentItemKey = parent.node.key;
                        searchExpandedKeys.indexOf(parentItemKey) === -1 ? searchExpandedKeys.push(parentItemKey) : _expandedKeys;
                    }
                }
            }
        });
        var _treeProps = {
            ref: function ref(comp) {
                return _this._refTree = comp;
            },
            filterTreeNode: this._searchFilterNode,
            expandedKeys: _expandedKeys,
            selectedKeys: _selectedKeys,
            checkedKeys: _checkedKeys,
            onCheck: this._onCheckTreeNode,
            onSelect: this._onSelectTreeNode,
            onExpand: this._onExpandTreeNode,
            autoExpandParent: this.state.autoExpandParent,
            className: this.className()
            //存在搜索展开的Key，则使用搜索展开的Key
        };if (searchExpandedKeys && searchExpandedKeys.length > 0) {
            if (_expandedKeys && _expandedKeys.length > 0) {
                _treeProps.expandedKeys = _expandedKeys.concat(searchExpandedKeys);
            } else {
                _treeProps.expandedKeys = searchExpandedKeys;
            }
        }
        var childViews = [];
        if (this.props.header) {
            //头部标题
            childViews.push(React.createElement(
                'div',
                { className: this.className('header') },
                this.props.header
            ));
        }
        if (this.props.searchFilter) {
            //带搜索过滤框的树结构
            if (this.props.searchMode == 'dropdown') {
                var treeNodes = this.props.nodes ? this.props.nodes : generateNodesDataFromChildren(children);
                childViews.push(React.createElement(YYTreeSearchTrigger, _extends({ treeNodes: treeNodes }, this.props)));
            } else {
                childViews.push(React.createElement(YYInputButton, { className: this.props.searchAddonBefore ? this.className('search-select') : this.className('search'),
                    addonBefore: this.props.searchAddonBefore,
                    placeholder: this.props.placeholder,
                    onPressEnter: this._searchFilterInputChange,
                    buttonClick: this._searchFilterInputClick }));
            }
        }
        //处理为数组object或react对象的情况
        if (_.isArray(children) && children.length > 0 || React.isValidElement(children)) {
            childViews.push(React.createElement(
                Tree,
                _.assign({}, this.props, _treeProps),
                children
            ));
        } else {
            if (this.props.emptyView) {
                childViews.push(this.props.emptyView);
            }
        }

        var children = childViews;
        //构建tree元素
        if (this.state.loading === true) {
            children = React.createElement(
                YYSpin,
                { spinning: true },
                childViews
            ); //显示加载中
        }
        return React.createElement(
            'div',
            { className: this.className('wrapper') + (this.props.bordered ? ' bordered' : ''), style: this.props.style },
            children
        );
    }
});
YYTree.childContextTypes = {
    onNodeDblClick: PropTypes.func
};
module.exports = YYTree;