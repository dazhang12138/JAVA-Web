'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _objectAssign = require('object-assign');

var _objectAssign2 = _interopRequireDefault(_objectAssign);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _rcAnimate = require('rc-animate');

var _rcAnimate2 = _interopRequireDefault(_rcAnimate);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; } /**
                                                                                                                                                                                                                   * Created by Dio on 2016/9/5.
                                                                                                                                                                                                                   */


var _require = require('antd'),
    Tree = _require.Tree;

var TreeNode = Tree.TreeNode;
var TreeNodeOverride = function TreeNodeOverride() {
    TreeNode.prototype.renderChildren = function (props) {
        var renderFirst = this.renderFirst;
        this.renderFirst = 1;
        var transitionAppear = true;
        if (!renderFirst && props.expanded) {
            transitionAppear = false;
        }
        var children = props.children;
        var newChildren = children;
        //重写此处的判断逻辑
        if (children && (children.type && children.type.isTreeNode || Array.isArray(children) && children.every(function (item) {
            return item.type && item.type.isTreeNode;
        }))) {
            var _cls;

            var cls = (_cls = {}, _defineProperty(_cls, props.prefixCls + '-child-tree', true), _defineProperty(_cls, props.prefixCls + '-child-tree-open', props.expanded), _cls);
            if (props.showLine) {
                cls[props.prefixCls + '-line'] = !props.last;
            }
            var animProps = {};
            if (props.openTransitionName) {
                animProps.transitionName = props.openTransitionName;
            } else if (_typeof(props.openAnimation) === 'object') {
                animProps.animation = (0, _objectAssign2.default)({}, props.openAnimation);
                if (!transitionAppear) {
                    delete animProps.animation.appear;
                }
            }
            newChildren = _react2.default.createElement(
                _rcAnimate2.default,
                _extends({}, animProps, {
                    showProp: 'data-expanded',
                    transitionAppear: transitionAppear,
                    component: ''
                }),
                !props.expanded ? null : _react2.default.createElement(
                    'ul',
                    { className: (0, _classnames2.default)(cls), 'data-expanded': props.expanded },
                    _react2.default.Children.map(children, function (item, index) {
                        return props.root.renderTreeNode(item, index, props.pos);
                    }, props.root)
                )
            );
        }
        return newChildren;
    };
};
module.exports = TreeNodeOverride;