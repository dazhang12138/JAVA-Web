'use strict';

/**
 * 重写rc-table组件相关实现 by dio
 */
var React = require('react');
var RcTable = require('rc-table');

var _require = require('rc-table/lib/utils'),
    measureScrollbar = _require.measureScrollbar;

var _ = require('lodash');
RcTable.prototype._getLeftFixedTable = function () {
    var columns = this.props.columns;

    var fixedColumns = columns.filter(function (column) {
        return column.fixed === 'left' || column.fixed === true;
    });
    return this._getTable({
        columns: fixedColumns,
        fixed: 'left'
    });
};
RcTable.prototype._getRightFixedTable = function () {
    var columns = this.props.columns;

    var fixedColumns = columns.filter(function (column) {
        return column.fixed === 'right';
    });
    return this._getTable({
        columns: fixedColumns,
        fixed: 'right'
    });
};
RcTable.prototype._getTable = function () {
    var _this = this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var columns = options.columns,
        fixed = options.fixed;
    var _props = this.props,
        prefixCls = _props.prefixCls,
        _props$scroll = _props.scroll,
        scroll = _props$scroll === undefined ? {} : _props$scroll,
        getBodyWrapper = _props.getBodyWrapper;
    var useFixedHeader = this.props.useFixedHeader;

    var bodyStyle = _.assign({}, this.props.bodyStyle);
    var headStyle = {};

    var tableClassName = '';
    if (scroll.x || columns) {
        tableClassName = prefixCls + '-fixed';
        bodyStyle.overflowX = bodyStyle.overflowX || 'auto';
    }

    if (scroll.y) {
        // maxHeight will make fixed-Table scrolling not working
        // so we only set maxHeight to body-Table here
        if (fixed) {
            //渲染左右固定列表格
            bodyStyle.height = bodyStyle.height || scroll.y;
        } else {
            //渲染中间非固定列表格
            bodyStyle.maxHeight = bodyStyle.maxHeight || scroll.y;
        }
        bodyStyle.overflowY = bodyStyle.overflowY || 'scroll';
        useFixedHeader = true;

        // Add negative margin bottom for scroll bar overflow bug
        var scrollbarWidth = measureScrollbar();
        if (scrollbarWidth > 0) {
            (fixed ? bodyStyle : headStyle).marginBottom = '-' + scrollbarWidth + 'px';
            (fixed ? bodyStyle : headStyle).paddingBottom = '0px';
        }
    }
    //add by zhuzj 追加固定列宽度计算，解决设置了固定列的width，表格被内容撑长的问题
    var fixedWidth = 0;
    if (fixed) {
        columns.map(function (column) {
            if (column.key === 'selection-column') {
                //勾选框列
                fixedWidth += 60;
            } else {
                if (column.isShow !== false && column.width) {
                    fixedWidth += parseInt(column.width);
                }
            }
        });
    }
    var renderTable = function renderTable() {
        var hasHead = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        var hasBody = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

        var tableStyle = {};
        if (!columns && scroll.x) {
            // not set width, then use content fixed width
            if (scroll.x === true) {
                tableStyle.tableLayout = 'fixed';
            } else {
                tableStyle.width = scroll.x;
            }
        }
        //add by zhuzj 修正固定列宽度
        if (fixed) {
            tableStyle.width = fixedWidth;
        }
        var tableBody = hasBody ? getBodyWrapper(React.createElement(
            'tbody',
            { className: prefixCls + '-tbody' },
            _this.getRows(columns, fixed)
        ), columns, fixed) : null; //追加getBodyWrapper追加columns,fixed参数 add by dio
        return React.createElement(
            'table',
            { className: tableClassName, style: tableStyle },
            _this.getColGroup(columns, fixed),
            hasHead ? _this.getHeader(columns, fixed) : null,
            tableBody
        );
    };

    var headTable = void 0;
    if (useFixedHeader) {
        headTable = React.createElement(
            'div',
            {
                className: prefixCls + '-header',
                ref: columns ? null : 'headTable',
                style: headStyle,
                onMouseOver: this.detectScrollTarget,
                onTouchStart: this.detectScrollTarget,
                onScroll: this.handleBodyScroll
            },
            renderTable(true, false)
        );
    }

    var BodyTable = React.createElement(
        'div',
        {
            className: prefixCls + '-body',
            style: bodyStyle,
            ref: 'bodyTable',
            onMouseOver: this.detectScrollTarget,
            onTouchStart: this.detectScrollTarget,
            onScroll: this.handleBodyScroll
        },
        renderTable(!useFixedHeader)
    );

    if (columns && columns.length) {
        var refName = void 0;
        if (columns[0].fixed === 'left' || columns[0].fixed === true) {
            refName = 'fixedColumnsBodyLeft';
        } else if (columns[0].fixed === 'right') {
            refName = 'fixedColumnsBodyRight';
        }
        var _bStyle = _.assign({}, bodyStyle);
        delete _bStyle.overflowX;
        delete _bStyle.overflowY;
        if (fixed) {
            _bStyle.height = 'auto';
            _bStyle.maxHeight = bodyStyle.maxHeight || scroll.y;
        }
        //add by zhuzj 修正空数据时固定列宽度不对齐的问题
        var _bOuterStyle = {};
        if (fixed) {
            if (fixed === 'right') {
                //修正右侧固定列显示滚动条宽度未参与计算的问题
                _bOuterStyle.width = fixedWidth + (bodyStyle.overflowY ? measureScrollbar() : 0);
            } else {
                _bOuterStyle.width = fixedWidth;
            }
        }
        //fix by zhuzj 解决固定表头下左右冻结列滚动条问题，_bStyle样式调整及作用到body-inner元素上
        BodyTable = React.createElement(
            'div',
            {
                className: prefixCls + '-body-outer',
                style: _bOuterStyle
            },
            React.createElement(
                'div',
                {
                    className: prefixCls + '-body-inner',
                    style: _bStyle,
                    ref: refName,
                    onMouseOver: this.detectScrollTarget,
                    onTouchStart: this.detectScrollTarget,
                    onScroll: this.handleBodyScroll
                },
                renderTable(!useFixedHeader)
            )
        );
    }
    var _views = [];
    if (headTable) _views.push(headTable);
    if (BodyTable) _views.push(BodyTable);
    return React.createElement(
        'span',
        null,
        _views
    );
};
RcTable.prototype.render = function () {
    var props = this.props;
    var prefixCls = props.prefixCls;

    var className = props.prefixCls;
    if (props.className) {
        className += ' ' + props.className;
    }
    if (props.columnsPageRange) {
        className += ' ' + prefixCls + '-columns-paging';
    }
    if (props.useFixedHeader || props.scroll && props.scroll.y) {
        className += ' ' + prefixCls + '-fixed-header';
    }
    className += ' ' + prefixCls + '-scroll-position-' + this.state.scrollPosition;

    var isTableScroll = this.isAnyColumnsFixed() || props.scroll.x || props.scroll.y;

    return React.createElement(
        'div',
        { className: className, style: props.style },
        this.getTitle(),
        React.createElement(
            'div',
            { className: prefixCls + '-content' },
            React.createElement(
                'div',
                { className: isTableScroll ? prefixCls + '-scroll' : '' },
                this._getTable(),
                this.getFooter()
            ),
            this.isAnyColumnsLeftFixed() && React.createElement(
                'div',
                { className: prefixCls + '-fixed-left' },
                this._getLeftFixedTable()
            ),
            this.isAnyColumnsRightFixed() && React.createElement(
                'div',
                { className: prefixCls + '-fixed-right' },
                this._getRightFixedTable()
            )
        )
    );
};
//exports["default"] = RcTable;
module.exports = RcTable;