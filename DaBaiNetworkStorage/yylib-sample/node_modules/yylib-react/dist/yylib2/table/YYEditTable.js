'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/**
 * Created by Dio on 2016/5/11.
 */
var React = require('react');
var YYClass = require('../base/YYClass');
var YYTable = require('./YYTable');
var PropTypes = YYClass.PropTypes;
var field = YYClass.field;
var _ = require('lodash');
var isArray = _.isArray;
var isFunction = _.isFunction;
var uiMetaFields = require('./uiMetaFields');
var RowsMoveUtil = require('./utils/RowsMoveUtil');
var editTableMetaFields = [].concat(_toConsumableArray(uiMetaFields), [field('enableRowClickEdit', undefined, PropTypes.bool, false, '是否启用点击行编辑')]);
require('./style/index.less');
//定义META
var uiMeta = {
    name: 'edittable',
    fields: editTableMetaFields
};

var YYEditTable = YYClass.create({
    uiMeta: uiMeta,
    getInitialState: function getInitialState() {
        return {
            columns: this._renderColumns(this.props.columns),
            allRows: _.cloneDeep(this.props.dataSource) || [],
            selectedRowKeys: this.props.selectedRowKeys || [],
            cellErrors: null //单元格内的错误信息标记
        };
    },
    componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
        if ('dataSource' in nextProps) {
            this.setState({ allRows: _.cloneDeep(nextProps.dataSource) || [], selectedRowKeys: [] });
        }
        if ('selectedRowKeys' in nextProps) {
            this.setState({ selectedRowKeys: nextProps.selectedRowKeys });
        }
        if ('columns' in nextProps) {
            this.setState({ columns: this._renderColumns(nextProps.columns) });
        }
    }
    //过滤掉已删除的数据
    , _filterRows: function _filterRows(rows) {
        var showRows = [];
        if (isArray(rows)) {
            for (var i = 0; i < rows.length; i++) {
                var row = rows[i];
                if (row.rowState && row.rowState == 'del') continue;
                showRows.push(rows[i]);
            }
        }
        return showRows;
    }
    /**
     * 将全部行数据依据rowState状态进行分组
     * @return { oldRows:[未变化的数据],addRows:[新增的数据],editRows:[修改过的数据],delRows:[删除的数据] }
     */
    , getRowDataGroupState: function getRowDataGroupState(rows) {
        var oldRows = []; //未变化的数据
        var addRows = []; //新增的数据
        var editRows = []; //修改过的数据
        var delRows = []; //删除的数据
        if (isArray(rows)) {
            for (var i = 0; i < rows.length; i++) {
                if (rows[i].rowState == 'add') {
                    addRows.push(rows[i]);
                } else if (rows[i].rowState == 'edit') {
                    editRows.push(rows[i]);
                } else if (rows[i].rowState == 'del') {
                    delRows.push(rows[i]);
                } else {
                    oldRows.push(rows[i]);
                }
            }
        }
        return { oldRows: oldRows, addRows: addRows, editRows: editRows, delRows: delRows };
    }
    //渲染列定义
    , _renderColumns: function _renderColumns(columns) {
        var columns = _.cloneDeep(columns);
        if (isArray(columns)) {
            for (var i = 0; i < columns.length; i++) {
                var col = columns[i];
                if (col.render) {
                    //为render绑定当前对象
                    col.render = col.render.bind(this);
                }
            }
        }
        return columns;
    }
    //构建新的一行数据
    , _newRow: function _newRow(rowData) {
        var rowKey = this.props.rowKey;
        var newRow = { rowState: 'add' }; //行状态默认标记为新增状态
        //单行编辑时，添加的行默认不可编辑
        newRow.isEdit = this.props.enableRowClickEdit === true ? false : true;
        //主键值不存在则自生成32位唯一键值
        newRow[rowKey] = !rowData || rowData[rowKey] === undefined || rowData[rowKey] === null ? YYClass.uuid32() : rowData[rowKey];
        if (_.isPlainObject(rowData)) newRow = _.assign({}, rowData, newRow); //如果存在指定行数据则覆写
        return newRow;
    }
    //pos-行插入的位置:first-首行、last-尾行
    , _addRow: function _addRow(options) {
        var pos = options.pos,
            rowId = options.rowId,
            rowData = options.rowData,
            callback = options.callback;

        var that = this;
        var rowKey = this.props.rowKey;
        var showRowNum = this.props.showRowNum;
        var rows = this.state.allRows || [];
        var newRows = [];
        if (_.isArray(rowData) && rowData.length > 0) {
            //处理批量数据
            _.forEach(rowData, function (row, idx) {
                newRows.push(that._newRow(row));
            });
        } else {
            //处理单行数据或空数据
            newRows.push(that._newRow(rowData));
        }
        if (pos == 'first') {
            //首行追加
            if (showRowNum) {
                //当显示行号时，首行每增加一行
                _.forEach(rows, function (currRow, idx) {
                    if (currRow.rowState !== 'add' && currRow.rowState !== 'del') {
                        currRow.rowState = 'edit'; //非新增|删除行则标记为修改状态
                    }
                });
            }
            rows = newRows.concat(rows);
        } else if (pos == 'last') {
            //尾行追加
            rows = rows.concat(newRows);
        } else {
            //指定位置插入
            var tempRows = [];
            if (rowId) {
                var posIndex = _.findIndex(rows, [rowKey, rowId]); //查找指定行id对应的索引位置
                if (posIndex >= 0) {
                    if (pos == 'before') {
                        //插入到指定行id前面
                        _.forEach(rows, function (row, index) {
                            if (posIndex == index) {
                                //插入到指定行id前面
                                tempRows = tempRows.concat(newRows);
                            }
                            if (showRowNum) {
                                //当显示行号时，则标记后面的行为修改状态
                                if (posIndex <= index && row.rowState !== 'add' && row.rowState !== 'del') {
                                    row.rowState = 'edit'; //非新增|删除行则标记为修改状态
                                }
                            }
                            tempRows.push(row);
                        });
                    } else if (pos == 'after') {
                        //插入到指定行id后面
                        _.forEach(rows, function (row, index) {
                            if (showRowNum) {
                                //当显示行号时，则标记后面的行为修改状态
                                if (posIndex < index && row.rowState !== 'add' && row.rowState !== 'del') {
                                    row.rowState = 'edit'; //非新增行则标记为修改状态
                                }
                            }
                            tempRows.push(row);
                            if (posIndex == index) {
                                //插入到指定行id后面
                                tempRows = tempRows.concat(newRows);
                            }
                        });
                    }
                    rows = tempRows;
                }
            }
        }
        this.setState({ allRows: rows }, function () {
            if (isFunction(callback)) callback(rows);
        });
    }
    //清理掉所有isEdit标记
    , _clearIsEdit: function _clearIsEdit(rows) {
        if (_.isArray(rows)) {
            for (var i = 0; i < rows.length; i++) {
                delete rows[i].isEdit;
                //注意对树表型数据结构进行处理
                if (rows[i].children) {
                    this._clearIsEdit(rows[i].children);
                }
            }
        }
        return rows;
    }
    //清除所有行的编辑状态
    , clearEditAll: function clearEditAll(callback) {
        var allRows = this._clearIsEdit(this.state.allRows);
        this.setState({ allRows: allRows }, callback);
    }
    //清空所有行数据
    , clearRowData: function clearRowData(callback) {
        this.setState({ allRows: [] }, callback);
    }
    //将指定行启用为编辑，已过期！（推荐使用editRowData方法,分页的情况下只能使用editRowData方法）
    , editRow: function editRow(rowIndex, callback) {
        console.error('本方法已过期，请使用editRowData(rowKey,callback)方法！');
    }
    //将树表型的children数据结构，转换成list型数据结构，方便遍历处理。
    , rowsTreeToList: function rowsTreeToList(rows) {
        var arr = [];
        for (var i = 0; i < rows.length; i++) {
            var row = rows[i];
            arr.push(row);
            if (_.isArray(row.children) && row.children.length > 0) {
                var subArr = this.rowsTreeToList(row.children);
                arr = arr.concat(subArr);
            }
        }
        return arr;
    }
    //依据指定行的键值，将其设置为编辑态，rowKey-行键值、callback-完成后回调
    , editRowData: function editRowData(rowKey, callback) {
        var _rows = this.state.allRows;
        var rows = this.rowsTreeToList(_rows); //对树表型数据结构进行特殊处理
        for (var i = 0; i < rows.length; i++) {
            var currRow = rows[i];
            //注意排除已标记删除的数据
            if (currRow.rowState !== 'del' && currRow[this.props.rowKey] == rowKey) {
                currRow.isEdit = true; //标记为编辑
                if (currRow.rowState !== 'add') {
                    currRow.rowState = 'edit'; //非新增行则标记为修改过
                }
                this.setState({ allRows: _rows }, function () {
                    if (isFunction(callback)) callback(_rows);
                });
                return;
            }
        }
    }
    //将指定行保存为非编辑，已过期！（推荐使用saveRowData方法,分页的情况下只能使用saveRowData方法）
    , saveRow: function saveRow(rowIndex, rowData, callback) {
        console.error('本方法已过期，请使用saveRowData(rowData,callback)方法！');
    }
    //将指定行的数据标记为非编辑态
    , saveRowData: function saveRowData(rowData, callback) {
        var _rows = this.state.allRows;
        var rows = this.rowsTreeToList(_rows); //对树表型数据结构进行特殊处理
        for (var i = 0; i < rows.length; i++) {
            var currRow = rows[i];
            //注意排除已标记删除的数据
            if (currRow.rowState !== 'del' && currRow[this.props.rowKey] == rowData[this.props.rowKey]) {
                delete currRow.isEdit; //标记为非编辑
                if (currRow.rowState !== 'add') {
                    currRow.rowState = 'edit'; //非新增行则标记为修改过
                }
                this.setState({ allRows: _rows }, function () {
                    if (isFunction(callback)) callback(_rows);
                });
                return;
            }
        }
    }
    //将指定行对应单元格数据进行保存，已过期！（推荐使用saveCellData方法,分页的情况下只能使用saveCellData方法）
    , saveCell: function saveCell(rowIndex, dataIndex, cellValue, callback) {
        console.error('本方法已过期，请使用saveCellData(rowKey,dataIndex,cellValue,callback)方法！');
    }
    /**
     * 更新指定行键值对应单元格的数据
     * @param rowId 行键值
     * @param dataIndex 列数据索引名
     * @param cellValue 单元格更新后的值
     * @param callback 更新后的回调
     */
    , saveCellData: function saveCellData(rowId, dataIndex, cellValue, callback) {
        var _rows = this.state.allRows;
        var rows = this.rowsTreeToList(_rows); //对树表型数据结构进行特殊处理
        for (var i = 0; i < rows.length; i++) {
            var currRow = rows[i];
            //注意排除已标记删除的数据
            if (currRow.rowState !== 'del' && currRow[this.props.rowKey] == rowId) {
                currRow[dataIndex] = cellValue;
                if (currRow.rowState !== 'add') {
                    currRow.rowState = 'edit'; //非新增行则标记为修改过
                }
                this.setState({ allRows: _rows }, function () {
                    if (isFunction(callback)) callback(_rows);
                });
                break;
            }
        }
    }
    /**
     * 更新指定列下的单元格值
     * @param dataIndex 列数据索引名
     * @param cellValue 单元格更新后的值
     * @param fillType 更新填充方式：all-整列更新(默认),up-从指定行向上更新,down-从指定行向下更新
     * @param rowId 当更新方式为 up|down 时，必须指定此参数值
     * @param callback 更新后的回调
     */
    , _saveColumnData: function _saveColumnData(options) {
        var dataIndex = options.dataIndex,
            cellValue = options.cellValue,
            fillType = options.fillType,
            rowId = options.rowId,
            callback = options.callback;

        var rowKey = this.props.rowKey;
        var _rows = this.state.allRows;
        var rows = this.rowsTreeToList(_rows); //对树表型数据结构进行特殊处理
        var existUpdated = false; //是否存在更新变更后的数据
        var startIndex = 0;
        var endIndex = 0;
        var currRowIndex = 0;
        //获取更新行范围（从当前位置向下|向上更新）
        if (fillType == 'up' || fillType == 'down') {
            for (currRowIndex = 0; currRowIndex < rows.length; currRowIndex++) {
                if (rows[currRowIndex][rowKey] == rowId) break;
            }
            if (fillType == 'up') {
                //从上往下更新到当前行位置
                startIndex = 0;
                endIndex = currRowIndex;
            } else if (fillType == 'down') {
                //从当前行位置更新到行尾位置
                startIndex = currRowIndex;
                endIndex = rows.length;
            }
        } else {
            //整列更新
            startIndex = 0;
            endIndex = rows.length;
        }
        //更新指定行范围内的数据
        for (var i = startIndex; i < endIndex; i++) {
            var currRow = rows[i];
            //注意排除已标记删除的数据
            if (currRow.rowState !== 'del') {
                currRow[dataIndex] = cellValue;
                if (currRow.rowState !== 'add') {
                    currRow.rowState = 'edit'; //非新增行则标记为修改过
                }
                if (existUpdated === false) existUpdated = true;
            }
        }
        if (existUpdated) {
            //重新渲染界面
            this.setState({ allRows: _rows }, function () {
                if (isFunction(callback)) callback(_rows);
            });
        } else {
            //无需重新渲染
            if (isFunction(callback)) callback(_rows);
        }
    }
    /**
     * 更新指定列下的单元格值
     * @param dataIndex 列数据索引名
     * @param cellValue 单元格更新后的值
     * @param callback 更新后的回调
     */
    , saveColumnData: function saveColumnData(dataIndex, cellValue, callback) {
        this._saveColumnData({ dataIndex: dataIndex, cellValue: cellValue, fillType: 'all', callback: callback });
    }
    /**
     * 从指定行开始向上更新指定列下的单元格值
     * @param rowId 当更新方式为 up|down 时，必须指定此参数值
     * @param dataIndex 列数据索引名
     * @param cellValue 单元格更新后的值
     * @param callback 更新后的回调
     */
    , saveColumnDataFillUp: function saveColumnDataFillUp(rowId, dataIndex, cellValue, callback) {
        this._saveColumnData({ rowId: rowId, dataIndex: dataIndex, cellValue: cellValue, fillType: 'up', callback: callback });
    }
    /**
     * 从指定行开始向下更新指定列下的单元格值
     * @param rowId 当更新方式为 up|down 时，必须指定此参数值
     * @param dataIndex 列数据索引名
     * @param cellValue 单元格更新后的值
     * @param callback 更新后的回调
     */
    , saveColumnDataFillDown: function saveColumnDataFillDown(rowId, dataIndex, cellValue, callback) {
        this._saveColumnData({ rowId: rowId, dataIndex: dataIndex, cellValue: cellValue, fillType: 'down', callback: callback });
    }
    //添加一行数据到首行，当rowData为数组时则进行批量添加
    , addRow: function addRow(rowData, callback) {
        this._addRow({ pos: 'first', rowData: rowData, callback: callback });
    }
    //添加一行数据到尾行，当rowData为数组时则进行批量添加
    , addRowLast: function addRowLast(rowData, callback) {
        this._addRow({ pos: 'last', rowData: rowData, callback: callback });
    }
    /**
     * 插入新一行到指定行posRowId的前面
     * options参数列表
     * @param posRowId 相对行键值
     * @param rowData 插入的行数据，当rowData为数组时则进行批量添加
     * @param callback 插入完成后的回调
     */
    , addRowBefore: function addRowBefore(options) {
        var posRowId = options.posRowId,
            rowData = options.rowData,
            callback = options.callback;

        this._addRow({ pos: 'before', rowId: posRowId, rowData: rowData, callback: callback });
    }
    /**
     * 插入新一行到指定行posRowId的后面
     * options参数列表
     * @param posRowId 相对行键值
     * @param rowData 插入的行数据，当rowData为数组时则进行批量添加
     * @param callback 插入完成后的回调
     */
    , addRowAfter: function addRowAfter(options) {
        var posRowId = options.posRowId,
            rowData = options.rowData,
            callback = options.callback;

        this._addRow({ pos: 'after', rowId: posRowId, rowData: rowData, callback: callback });
    }
    //删除指定键值的行数据，当rowId为array[string]时则批量删除。
    , delRow: function delRow(rowId, callback) {
        var rowIds = _.isArray(rowId) ? rowId : [rowId]; //支持单个和批量删除
        //获取当前所有行数据
        var _rows = this.state.allRows;
        var rows = this.rowsTreeToList(_rows); //对树表型数据结构进行特殊处理
        var _rowKey = this.props.rowKey;
        var showRowNum = this.props.showRowNum;
        var removeKeys = []; //需要清理的行键值集合
        //标记需要删除的数据
        for (var i = 0; i < rowIds.length; i++) {
            _.forEach(rows, function (row, index) {
                if (row[_rowKey] == rowIds[i]) {
                    //当新增的数据直接被删除时则清理掉，而不是标记删除。
                    if (row.rowState === 'add') {
                        removeKeys.push(rowIds[i]);
                    }
                    row.rowState = 'del'; //标记为已删除
                }
            });
        }
        //对新增未保存的数据直接删除后进行清理
        for (var removeIdx = 0; removeIdx < removeKeys.length; removeIdx++) {
            _.remove(_rows, function (_row) {
                return _row[_rowKey] == removeKeys[removeIdx];
            });
        }
        //当显示行序号时，需要把删除行之后的数据行标记为修改状态
        if (showRowNum) {
            var firstDelRowIndex = _rows.length;
            _.forEach(_rows, function (row, index) {
                if (row.rowState === 'del') {
                    //从上往下找到第一个被标记删除的行，记录其索引位置
                    firstDelRowIndex = index;
                }
                if (index > firstDelRowIndex) {
                    //标记删除行之后的所有行数据，都标记为修改状态
                    if (row.rowState !== 'add' && row.rowState !== 'del') {
                        row.rowState = 'edit'; //非新增|删除行则标记为修改过
                    }
                }
            });
        }
        this.setState({ allRows: _rows, selectedRowKeys: [] }, function () {
            if (isFunction(callback)) callback(_rows);
        });
    }
    /**
     * 获取当前数据源(全部行数据)
     */
    , getDataSource: function getDataSource() {
        return this.state.allRows;
    }
    /**
     * 获取对应行状态的全部数据
     * options参数列表
     * @param rowState "all"|"add"|"edit"|"del"|"old"，获取指定状态的行数据，不指定则默认"all"获取全部状态行数据
     * @param clearIsEdit 是否清除掉编辑态，默认true，如果不需要清除则设置为false
     * @param clearNewId 是否清除掉新增数据时生成的主键值，默认true
     * @param clearDel 当获取全部(all)数据时，是否清理掉被标记删除的数据
     */
    , getRowData: function getRowData(options) {
        var _ref = options || {},
            rowState = _ref.rowState,
            clearIsEdit = _ref.clearIsEdit,
            clearNewId = _ref.clearNewId,
            clearDel = _ref.clearDel;

        var rowKey = this.props.rowKey;
        //克隆一份副本
        var cloneRows = _.cloneDeep(this.state.allRows);
        //清除掉isEdit标识
        var allRows = clearIsEdit === false ? cloneRows : this._clearIsEdit(cloneRows);
        if (rowState == 'add' || rowState == 'edit' || rowState == 'del' || rowState == 'old') {
            //TODO 目前没有对表树形式的数据格式进行特殊处理
            var groups = this.getRowDataGroupState(allRows);
            if (rowState == 'add') {
                if (clearNewId === undefined || clearNewId === true) {
                    //清理掉自动生成的id
                    _.forEach(groups.addRows, function (row, index) {
                        delete row[rowKey];
                    });
                }
                return groups.addRows;
            } else if (rowState == 'edit') {
                return groups.editRows;
            } else if (rowState == 'del') {
                return groups.delRows;
            } else if (rowState == 'old') {
                return groups.oldRows;
            }
        } else {
            //默认all
            //清理掉新增数据自动生成的id
            if (clearNewId === undefined || clearNewId === true) {
                _.forEach(allRows, function (row, index) {
                    if (row.rowState == 'add') delete row[rowKey];
                });
            }
            //清理掉被标记删除的数据
            if (clearDel == true) {
                allRows = _.filter(allRows, function (row) {
                    return row.rowState !== 'del';
                });
            }
            return allRows;
        }
    }
    /**
     * 获取当前选中行的数据
     * @param clearNewId 是否清除掉新增数据时生成的主键值，默认true
     */
    , getSelectedRowData: function getSelectedRowData(options) {
        var rowKey = this.props.rowKey;

        var _ref2 = options || {},
            clearNewId = _ref2.clearNewId;

        var selectedRowKeys = this.getSelectedRowKeys();
        var rowData = this.getRowData({ clearNewId: false });
        //匹配出当前勾选行数据
        var selectedRowData = _.filter(rowData, function (row) {
            if (_.includes(selectedRowKeys, row[rowKey])) {
                return row;
            }
        });
        //清理新增行自动生成的主键值
        if (clearNewId === undefined || clearNewId === true) {
            _.forEach(selectedRowData, function (row, index) {
                if (row.rowState == 'add') delete row[rowKey];
            });
        }
        return selectedRowData;
    }
    //获取当前选中的行键值
    , getSelectedRowKeys: function getSelectedRowKeys() {
        return this.state.selectedRowKeys;
    }
    //清除勾选状态
    , clearSelectedRowKeys: function clearSelectedRowKeys() {
        this.setState({ selectedRowKeys: [] });
    }
    //获取已删除行的行键值
    , getDeleteRowKeys: function getDeleteRowKeys() {
        var rows = this.state.allRows;
        var delKeys = [];
        //已删除的数据
        for (var i = 0; i < rows.length; i++) {
            if (rows[i].rowState == 'del') {
                delKeys.push(rows[i][this.props.rowKey]);
            }
        }
        return delKeys;
    }
    /**
     * 通过行键值获取指定行数据(rowData)
     * options参数列表
     * @param rowKey 行id键值
     */
    , getRowDataByKey: function getRowDataByKey(options) {
        var _ref3 = options || {},
            rowKey = _ref3.rowKey;

        var rowDatas = this.rowsTreeToList(this.getDataSource());
        var rowData = _.find(rowDatas, [this.props.rowKey, rowKey]);
        return rowData;
    }
    /**
     * 获取指定单元格数据(cellData)
     * options参数列表
     * @param rowKey 行id键值
     * @param dataIndex 列数据索引名
     */
    , getCellDataByKey: function getCellDataByKey(options) {
        var _ref4 = options || {},
            rowKey = _ref4.rowKey,
            dataIndex = _ref4.dataIndex;

        var rowData = this.getRowDataByKey(options);
        return rowData[dataIndex];
    }
    /**
     * 将指定行进行移动
     * 参数options列表
     * @param rowId string|array 需要移动的行键值，一般为勾选的行键值
     * @param pos number 移动的位置 负数表示上移，正数表示下移，例如：-1 为上移一行、1 为下移一行
     * @param clearSelected boolean 移动后是否清除勾选状态
     * @param callback 移动完成后的回调
     */
    , rowMoveTo: function rowMoveTo(options) {
        var _ref5 = options || {},
            rowId = _ref5.rowId,
            pos = _ref5.pos,
            clearSelected = _ref5.clearSelected,
            callback = _ref5.callback;

        var rowKey = this.props.rowKey;
        var showRowNum = this.props.showRowNum;
        var allRows = this.state.allRows;
        var moveRowId = _.isArray(rowId) && rowId.length == 1 ? rowId[0] : rowId; //数组只有一个值时，则作为字符串id进行处理
        var oldRowIds = []; //记录移动前的显示rowId的顺序
        //当显示行序号时，需要记录移动前的行顺序，以便移动完成后处理rowState为修改状态
        if (showRowNum) {
            for (var oldIdx = 0; oldIdx < allRows.length; oldIdx++) {
                var row = allRows[oldIdx];
                if (row.rowState && row.rowState == 'del') continue;
                oldRowIds.push(row[rowKey]);
            }
        }
        if (_.isArray(moveRowId)) {
            //批量移动多个行(两个及以上行数)
            //由于勾选时不一定是正顺序，会导致移动不是按正顺序移动，所以将勾选键值进行正序排列后再移动
            var sortRowIds = [];
            //从上往下正顺排列勾选值
            _.forEach(allRows, function (row) {
                if (_.includes(moveRowId, row[rowKey])) {
                    sortRowIds.push(row[rowKey]);
                }
            });
            //批量移动行
            _.forEach(sortRowIds, function (_rowId) {
                allRows = RowsMoveUtil.moveTo({ rows: allRows, rowKey: rowKey, rowId: _rowId, pos: pos, isRowIndex: function isRowIndex(row) {
                        return row.rowState && row.rowState == 'del' ? false : true; //被删除的数据不参与行索引计算
                    } });
            });
        } else {
            //指定字符串的rowId进行移动
            //单个移动行
            allRows = RowsMoveUtil.moveTo({ rows: allRows, rowKey: rowKey, rowId: moveRowId, pos: pos, isRowIndex: function isRowIndex(row) {
                    return row.rowState && row.rowState == 'del' ? false : true; //被删除的数据不参与行索引计算
                } });
        }
        //当显示行序号时，移动完成后，将移动后行顺序rowNum发生变更的行标记rowState为修改状态
        if (showRowNum) {
            var firstDiffRowIndex = false; //从上往下匹配到第一个行数据发生变化的位置
            for (var movedIdx = 0; movedIdx < allRows.length; movedIdx++) {
                var movedRow = allRows[movedIdx];
                if (movedRow.rowState && movedRow.rowState == 'del') continue;
                if (firstDiffRowIndex === false && movedRow[rowKey] !== oldRowIds[movedIdx]) {
                    firstDiffRowIndex = movedIdx;
                }
                if (firstDiffRowIndex !== false && movedIdx >= firstDiffRowIndex) {
                    //标记第一个行位置对应数据发生变更的行之后的所有行数据，都标记为修改状态
                    if (movedRow.rowState !== 'add' && movedRow.rowState !== 'del') {
                        movedRow.rowState = 'edit'; //非新增|删除行则标记为修改过
                    }
                }
            }
        }
        //是否清理勾选状态
        if (clearSelected === true) {
            this.setState({ allRows: allRows, selectedRowKeys: [] }, callback);
        } else {
            this.setState({ allRows: allRows }, callback);
        }
    }
    //当行被勾选|全选，selectedRowKeys-被勾选的行keys，selectedRows-被勾选的行数据
    , _onRowChangeChecked: function _onRowChangeChecked(selectedRowKeys, selectedRows) {
        this.setState({ selectedRowKeys: selectedRowKeys });
    },

    //点击行进入编辑模式（同一时间只编辑一行）
    _onRowClick: function _onRowClick(record, index) {
        if (_.isFunction(this.props.onRowClick)) {
            this.props.onRowClick(record, index);
        }
        if (this.props.enableRowClickEdit == true) {
            this.clearEditAll();
            this.editRowData(record[this.props.rowKey]);
        }
    }
    /**
     *获取所有单元格的错误消息
     * 格式如下：
     *  {
     *     '行键值1':{
     *          'A字段键值':'A错误描述',
     *          'B字段键值':'B错误描述',
     *          ...
     *     },
     *     '行键值2':{
     *          'A字段键值':'A错误描述',
     *          'B字段键值':'B错误描述',
     *          ...
     *     },
     *     ...
     *  }
     */
    , getAllCellError: function getAllCellError() {
        return this.state.cellErrors;
    }
    /**
     * 设置所有单元格的错误消息，cellErrors错误消息对象集合格式必须是通过addCellError方法构建的错误消息内容格式。
     * 内容格式参看getAllCellError()方法返回的格式。
     */
    , setAllCellError: function setAllCellError(cellErrors) {
        this.setState({ cellErrors: cellErrors });
    }
    /**
     *给cellErrors对象集合里面添加一个新的单元格错误消息，不会立即刷新，需要手动刷新或调用setAllCellError方法进行刷新。
     *cellErrors 错误消息集合对象，可以是getAllCellError()获取的对象或者空对象{}
     *options={
     * rowId string 行键值
     * dataIndex string 列定义键值
     * errorMsg string 描述错误
     *}
     *return 添加后的错误消息集合对象，内容格式参看getAllCellError()方法返回的格式。
     */
    , addCellError: function addCellError(cellErrors, options) {
        var rowId = options.rowId,
            dataIndex = options.dataIndex,
            errorMsg = options.errorMsg;

        cellErrors = cellErrors || {};
        cellErrors[rowId] = cellErrors[rowId] || {};
        cellErrors[rowId][dataIndex] = errorMsg;
        return cellErrors;
    }
    /**
     *清除指定单元格的错误消息
     *options={
     * rowId string 行键值
     * dataIndex string 列定义键值
     *}
     */
    , clearCellError: function clearCellError(options) {
        var rowId = options.rowId,
            dataIndex = options.dataIndex;
        var cellErrors = this.state.cellErrors;

        if (cellErrors && cellErrors[rowId] && cellErrors[rowId][dataIndex]) {
            delete cellErrors[rowId][dataIndex];
            this.setState({ cellErrors: cellErrors });
        }
    }
    /**
     *设置指定单元格的错误消息，立即刷新
     *options={
     * rowId string 行键值
     * dataIndex string 列定义键值
     * errorMsg string 描述错误
     *}
     */
    , setCellError: function setCellError(options) {
        var rowId = options.rowId,
            dataIndex = options.dataIndex,
            errorMsg = options.errorMsg;
        var cellErrors = this.state.cellErrors;

        cellErrors = this.addCellError(cellErrors, { rowId: rowId, dataIndex: dataIndex, errorMsg: errorMsg });
        this.setState({ cellErrors: cellErrors });
    }
    /**
     *获取指定单元格的错误消息
     *options={
     * rowId string 行键值
     * dataIndex string 列定义键值
     *}
     */
    , getCellError: function getCellError(options) {
        var rowId = options.rowId,
            dataIndex = options.dataIndex;
        var cellErrors = this.state.cellErrors;

        cellErrors = cellErrors || {};
        cellErrors[rowId] = cellErrors[rowId] || {};
        return cellErrors[rowId][dataIndex];
    },
    render: function render() {
        var rowSelection = this.props.rowSelection == false ? false : _.assign({ selectedRowKeys: this.state.selectedRowKeys, onChange: this._onRowChangeChecked }, this.props.rowSelection);
        var pagination = this.props.pagination ? this.props.pagination : false;
        var showRows = this._filterRows(this.state.allRows);
        return React.createElement(YYTable, _extends({}, this.props, { dataSource: showRows, columns: this.state.columns,
            onRowClick: this._onRowClick,
            rowSelection: rowSelection, pagination: pagination }));
    }
});

module.exports = YYEditTable;